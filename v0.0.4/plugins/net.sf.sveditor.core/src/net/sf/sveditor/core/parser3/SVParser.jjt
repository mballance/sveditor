/****************************************************************************
 *                               SVParser.jjt
 *
 * SystemVerilog grammar derived from the language grammar in the 1.0 
 * edition of the SystemVerilog spec
 ****************************************************************************/

options {
//  LOOKAHEAD      = 1;
  STATIC = false ;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = true;
}

PARSER_BEGIN(SVParser)

package net.sf.sveditor.core.parser3;

public class SVParser {

}


PARSER_END(SVParser)


/**
 * Rules for Whitespace 
 */
SKIP :
{
  " " | "\t" | "\n" | "\r" | "\f" | "\r\n"
}

/* Comments removed for now */

/* Reserved words */
TOKEN :
{
  < EQ_3:           "===">
| < EQ_2:           "==">
| < EQ_1:    		"=">
| < NE_1:           "!=">
| < NE_2:           "!==">
| < LSE:            "<<=">
| < LLSE:           "<<<=">
| < LLS:            "<<<">
| < RLS:            ">>>">
| < LS:             "<<">
| < RS:             ">>">
| < LE:             "<=">
| < GE:             ">=">
| < LT:             "<">
| < GT:             ">">
| < PLUS:			"+">
| < LPAREN:         "(">
| < RPAREN:         ")">
| < QMARK:          "?">
| < COMMA:          ",">
| < HASH:           "#">
| < ALIAS: 			"alias" >
| < ALWAYS: 		"always">
| < ALWAYS_COMB:	"always_comb">
| <	ALWAYS_FF: 		"always_ff">
| <	ALWAYS_LATCH: 	"always_latch">
| <	AND: 			"and">
| < ASSERT: 		"assert">
| <	ASSIGN: 		"assign">
| < ASSUME: 		"assume">
| < AUTOMATIC: 		"automatic">
| < BEFORE: 		"before">
| < BEGIN:			"begin">
| < BIND:			"bind">
| < BINS:			"bins">
| < BINSOF:			"binsof">
| < BIT:			"bit">
| < BREAK:			"break">
| < BUF:		"buf">
| < BUFIF0:		"bufif0">
| < BUFIF1:		"bufif1">
| < BYTE:		"byte">
| < CASE:		"case">
| < CASEX:		"casex">
| < CASEZ:		"casez">
| < CELL:		"cell">
| < CHANDLE:	"chandle">
| < CLASS:		"class">
| < CLOCKING:	"clocking">
| < CMOS:		"cmos">
| < CONFIG:		"config">
| < CONST:		"const">
| < CONSTRAINT:	"constraint">
| < CONTEXT:	"context">
| < CONTINUE:	"continue">
| < COVER:		"cover">
| < COVERGROUP:	"covergroup">
| < COVERPOINT: "coverpoint">
| < CROSS:		"cross">
| < DEASSIGN:	"deassign">
| < T_DEFAULT:	"default">
| < DEFPARAM:	"defparam">
| < DESIGN:		"design">
| < DISABLE:	"disable">
| < DIST:		"dist">
| < DO:			"do">
| < EDGE:		"edge">
| < ELSE:		"else">
| < END:		"end">
| < ENDCASE:	"endcase">
| < ENDCLASS:		"endclass">
| < ENDCLOCKING:	"endclocking">
| < ENDCONFIG:		"endconfig">
| < ENDFUNCTION:	"endfunction">
| < ENDGENERATE:	"endgenerate">
| < ENDGROUP:		"endgroup">
| < ENDINTERFACE:	"endinterface">
| < ENDMODULE:		"endmodule">
| < ENDPACKAGE:		"endpackage">
| < ENDPRIMITIVE:	"endprimitive">
| < ENDPROGRAM:		"endprogram">
| < ENDPROPERTY:	"endproperty">
| < ENDSPECIFY:		"endspecify">
| < ENDSEQUENCE:	"endsequence">
| < ENDTABLE:		"endtable">
| < ENDTASK:		"endtask">
| < ENUM:			"enum">
| < EVENT:			"event">
| < EXPECT:			"expect">
| < EXPORT:			"export">
| < EXTENDS:		"extends">
| < EXTERN:			"extern">
| < FINAL:			"final">
| < FIRST_MATCH:	"first_match">
| < FOR:			"for">
| < FORCE:			"force">
| < FOREACH:		"foreach">
| < FOREVER:		"forever">
| < FORK:			"fork">
| < FORKJOIN:		"forkjoin">
| < FUNCTION:		"function">
| < GENERATE:		"generate">
| < GENVAR:			"genvar">
| < HIGHZ0:			"highz0">
| < HIGHZ1:			"highz1">
| < IF:				"if">
| < IFF:			"iff">
| < IFNONE:			"ifnone">
| < IGNORE_BINS:	"ignore_bins">
| < ILLEGAL_BINS:	"illegal_bins">
| < IMPORT:			"import">
| < INCDIR:			"incdir">
| < T_INCLUDE:		"include">
| < INITIAL:		"initial">
| < INOUT:			"inout">
| < INPUT:			"input">
| < INSIDE:			"inside">
| < INSTANCE:		"instance">
| < INT:			"int">
| < INTEGER:		"integer">
| < INTERFACE:		"interface">
| < INTERSECT:		"intersect">
| < JOIN:			"join">
| < JOIN_ANY:		"join_any">
| < JOIN_NONE:		"join_none">
| < LARGE:			"large">
| < LIBLIST:		"liblist">
| < LIBRARY:		"library">
| < LOCAL:			"local">
| < LOCALPARAM:		"localparam">
| < LOGIC:			"logic">
| < LONGINT:		"longint">
| < MACROMODULE:	"macromodule">
| < MATCHES:		"matches">
| < MEDIUM:			"medium">
| < MODPORT:		"modport">
| < MODULE:			"module">
| < NAND:			"nand">
| < NEGEDGE:		"negedge">
| < NEW:			"new">
| < NMOS:			"nmos">
| < NOR:			"nor">
| < NOSHOWCANCELLED:	"noshowcancelled">
| < NOT:				"not">
| < NOTIF0:				"notif0">
| < NOTIF1:				"notif1">
| < NULL:				"null">
| < OPTION:             "option">
| < OR:					"or">
| < OUTPUT:				"output">
| < PACKAGE:			"package">
| < PACKED:				"packed">
| < PARAMETER:			"parameter">
| < PMOS:				"pmos">
| < POSEDGE:			"posedge">
| < PRIMITIVE:			"primitive">
| < PRIORITY:			"priority">
| < PROGRAM:			"program">
| < PROPERTY:			"property">
| < PROTECTED:			"protected">
| < PULL0:				"pull0">
| < PULL1:				"pull1">
| < PULLDOWN:			"pulldown">
| < PULLUP:				"pullup">
| < PULSESTYLE_ONEVENT:	"pulsestyle_onevent">
| < PULSESTYLE_ONDETECT:	"pulsestyle_ondetect">
| < PURE:					"pure">
| < RAND:					"rand">
| < RANDC:					"randc">
| < RANDCASE:				"randcase">
| < RANDSEQUENCE:			"randsequence">
| < RCMOS:					"rcmos">
| < REAL:					"real">
| < REALTIME:				"realtime">
| < REF:					"ref">
| < REG:					"reg">
| < RELEASE:				"release">
| < REPEAT:					"repeat">
| < RETURN:					"return">
| < RNMOS:					"rnmos">
| < RPMOS:					"rpmos">
| < RTRAN:					"rtran">
| < RTRANIF0:				"rtranif0">
| < RTRANIF1:				"rtranif1">
| < SCALARED:				"scalared">
| < SEQUENCE:				"sequence">
| < SHORTINT:				"shortint">
| < SHORTREAL:				"shortreal">
| < SHOWCANCELLED:			"showcancelled">
| < SIGNED:					"signed">
| < SMALL:					"small">
| < SOLVE:					"solve">
| < SPECIFY:				"specify">
| < SPECPARAM:				"specparam">
| < STATIC:					"static">
| < STRING:					"string">
| < STRONG0:				"strong0">
| < STRONG1:				"strong1">
| < STRUCT:					"struct">
| < SUPER:					"super">
| < SUPPLY0:				"supply0">
| < SUPPLY1:				"supply1">
| < TABLE:					"table">
| < TAGGED:					"tagged">
| < TASK:					"task">
| < THIS:					"this">
| < THROUGHOUT:				"throughout">
| < TIME:					"time">
| < TIMEPRECISION:			"timeprecision">
| < TIMEUNIT:				"timeunit">
| < TRAN:					"tran">
| < TRANIF0:				"tranif0">
| < TRANIF1:				"tranif1">
| < TRI:					"tri">
| < TRI0:					"tri0">
| < TRI1:					"tri1">
| < TRIAND:					"triand">
| < TRIOR:					"trior">
| < TRIREG:					"trireg">
| < TYPE:					"type">
| < TYPE_OPTION:            "type_option">
| < TYPEDEF:				"typedef">
| < UNION:					"union">
| < UNIQUE:					"unique">
| < UNSIGNED:				"unsigned">
| < USE:					"use">
| < UWIRE:					"uwire">
| < VAR:					"var">
| < VECTORED:				"vectored">
| < VIRTUAL:				"virtual">
| < VOID:					"void">
| < WAIT:					"wait">
| < WAIT_ORDER:				"wait_order">
| < WAND:					"wand">
| < WEAK0:					"weak0">
| < WEAK1:					"weak1">
| < WHILE:					"while">
| < WILDCARD:				"wildcard">
| < WIRE:					"wire">
| < WITH:					"with">
| < WITHIN:					"within">
| < WOR:					"wor">
| < XNOR:					"xnor">
| < XOR:					"xor">
| < PATHPULSE:              "PATHPULSE$">
| < RANDOMIZE:              "randomize">
| < UNIT:                   "$unit">
| < ROOT:                   "$root">
| < SEMICOLON:              ";">
| < TS_S:                   "s">
| < TS_MS:                  "ms">
| < TS_US:                  "us">
| < TS_NS:                  "ns">
| < TS_PS:                  "ps">
| < TS_FS:                  "fs">
| < TS_STEP:                "step">
| < DPI:                    "\"DPI\"">
| < DPI_C:                  "\"DPI-C\"">
| < EXP:                    ["e","E"]>
| < TF_IDENT:               ("$" ["a"-"z","A"-"Z","0"-"9","_","$"](["a"-"z","A"-"Z","0"-"9","_","$"])*)>
| < S_IDENT:                (["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_","$"])*)>
| < C_IDENT:                (["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*)>
| < BINARY_VALUE:           ["0","1","z","Z","?","x","X"] (["0","1","z","Z","?","x","X","_"])*>
| < HEX_VALUE:              (["0"-"9","a"-"f","A"-"F","z","Z","?","x","X"] (["0"-"9","a"-"f","A"-"F","z","Z","?","x","X","_"])*)>
| < DEC_VALUE:              (["0"-"9"] (["0"-"9","_"])*)>
| < NZ_UNSIGNED_VALUE:      (["1"-"9"] (["0"-"9","_"])*)>
| < ATTR_START:             "(*">
| < ATTR_END:               "*)">
| <ESCAPE:                  "\\">
| <STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["\n","\t","\b","\r","\f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\"">
| < DEC_DIGIT:              (["0"-"9"])>
| < NZ_DEC_DIGIT:           (["1"-"9"])>
| < OCTAL_DIGIT:              (["0"-"7","z","Z","?","x","X"])>
| < BIN4S_DIGIT:            ("0" | "1" | "x" | "X" | <QMARK> | "b" | "B")>
}

/****************************************************************************
 * A.1.2 SystemVerilog source text
 ****************************************************************************/
SimpleNode description() :
{
}
{
	 (
		
		(LOOKAHEAD(2) attribute_instance())*
			( 
	 		module_declaration()   		//|
		/*	 udp_declaration()    		| TODO: */
	 		// interface_declaration() 	| 
		/*
	 		program_declaration()		|
	 		package_declaration()		|
			LOOKAHEAD(3)
	 		package_item()   			| 
	 		bind_directive()
	 		config_declaration()
	 	 */
	 		)                    
	 )* 
	 <EOF>
	 
	 { return jjtThis; }
}

void module_nonansi_header() :
{
	Token module_id = null;
}
{
	(attribute_instance())* module_keyword() [lifetime()] 
		module_id = identifier() 
		[ parameter_port_list() ] list_of_ports() <SEMICOLON>
	{
		System.out.println("non-ansi id: " + module_id.image);
	}
}

void module_ansi_header() :
{
	Token module_id = null;
}
{
  (attribute_instance())* module_keyword() [lifetime()] 
  	module_id = identifier()  
  	[ parameter_port_list() ]
	[ list_of_port_declarations() ] <SEMICOLON>
	
  {
  	System.out.println("module_id=" + module_id.image);
  }
}

void module_keyword() :
{
}
{
	<MODULE> | <MACROMODULE>
}

void module_declaration() : {} {
	module_keyword() [lifetime()] identifier() [parameter_port_list()]
	(
	
//	<LPAREN> port() ( <COMMA> port() )* <RPAREN>
//	<LPAREN> [(attribute_instance())* ansi_port_declaration() ( <COMMA> (attribute_instance())* ansi_port_declaration())* ] <RPAREN>

		// Non-ANSI
		  list_of_ports() <SEMICOLON> [ timeunits_declaration() ] ( module_item() )* 
		| [ list_of_port_declarations() ] <SEMICOLON> [ timeunits_declaration() ] (non_port_module_item())*
	)
	<ENDMODULE> [ ":" identifier() ]
	
	/*
	module_nonansi_header() [ timeunits_declaration() ] ( module_item() )*
	 <ENDMODULE> [ ":" identifier() ]
	| module_ansi_header() [ timeunits_declaration() ] (non_port_module_item())*
	<ENDMODULE> [ ":" identifier() ]
	| ( attribute_instance() )* module_keyword() [ lifetime() ] identifier() <LPAREN> ".*" <RPAREN> <SEMICOLON>
		[ timeunits_declaration() ] (module_item())* <ENDMODULE> [ ":" identifier() ]
	| <EXTERN> module_nonansi_header()
	| <EXTERN> module_ansi_header()
	 */
}

void interface_nonansi_header() :
{
}
{
    (attribute_instance())* <INTERFACE> [lifetime()] identifier()
		[parameter_port_list()] list_of_ports() <SEMICOLON>
}

		
void interface_ansi_header() :
{
}
{
	(attribute_instance())* <INTERFACE> [lifetime()] identifier()
	[parameter_port_list()] [list_of_port_declarations()] <SEMICOLON>
}

/*
void interface_declaration() : {} {
	// CHG: re-organize to eliminate ansi/nonansi header declaration
	(attribute_instance())* <INTERFACE> [lifetime()] identifier()
		[parameter_port_list()] 
		(list_of_ports() [timeunits_declaration()] (interface_item())* <SEMICOLON> | 
			[list_of_port_declarations()] [timeunits_declaration()] (non_port_interface_item())*) 
		<ENDINTERFACE> [ ":" identifier() ]
	//* FIXME:
	//| (attribute_instance())* <INTERFACE> identifier() <LPAREN> ".*" <RPAREN> <SEMICOLON>
//		[ timeunits_declaration() ] (interface_item())*
//		<ENDINTERFACE> [ ":" identifier() ]
//	| <EXTERN> interface_nonansi_header()
//	| <EXTERN> interface_ansi_header()

}
 */

void program_nonansi_header() :
{
}
{
    (attribute_instance())* <PROGRAM> [ lifetime() ] identifier()
		[parameter_port_list()] list_of_ports() <SEMICOLON>
}

void program_ansi_header() :
{
}
{
	(attribute_instance())* <PROGRAM> [lifetime()] identifier()
	[parameter_port_list()] [ list_of_port_declarations() ] <SEMICOLON>
}

void program_declaration() : {} {
	// CHG: eliminate ansi/non-ansi declarations
	(attribute_instance())* <PROGRAM> [ lifetime() ] identifier() 
		[parameter_port_list()] 
		(list_of_ports() <SEMICOLON> [timeunits_declaration() ] (program_item())* |
		 [list_of_port_declarations()] <SEMICOLON> [ timeunits_declaration() ] (non_port_program_item())*)
		<ENDPROGRAM> [ ":" identifier() ]
	/** FIXME:
	| (attribute_instance())* <PROGRAM> identifier() <LPAREN> ".*" <RPAREN> <SEMICOLON>
		[ timeunits_declaration() ] (program_item())*
		<ENDPROGRAM> [ ":" identifier() ]
	| <EXTERN> program_nonansi_header()
	| <EXTERN> program_ansi_header()
	 */

}

void class_declaration() :
{
}
{
	[ <VIRTUAL> ] <CLASS> [ lifetime() ] identifier() [ parameter_port_list() ]
	[ <EXTENDS> class_type() [ <LPAREN> list_of_arguments() <RPAREN> ] ] <SEMICOLON>
	(class_item())*
	<ENDCLASS> [ ":" identifier() ]
}

void package_declaration() :
{
}
{
	(attribute_instance())* <PACKAGE> identifier() <SEMICOLON>
		[timeunits_declaration()] ((attribute_instance())* package_item())*
	<ENDPACKAGE> [ ":" identifier() ]
}

void timeunits_declaration() : {} {
	// CHG: reorganize
	<TIMEUNIT> time_literal() <SEMICOLON>
		[<TIMEPRECISION> time_literal() <SEMICOLON>]
	| <TIMEPRECISION> time_literal() <SEMICOLON>
		[<TIMEUNIT> time_literal() <SEMICOLON>]
}


/****************************************************************************
 * A.1.3 Module parameters and ports
 ****************************************************************************/
void parameter_port_list() :
{
}
{
	// CHG: reorganize to minimize ambiguous choices
	<HASH> <LPAREN> 
		[ 
		list_of_param_assignments() (<COMMA> parameter_port_declaration())* |
		parameter_port_declaration() (<COMMA> parameter_port_declaration())*
		]
	<RPAREN>
}

void parameter_port_declaration() : {} {
	
	<TYPE> list_of_type_assignments()
	| parameter_declaration()
	| data_type() list_of_param_assignments()
}

void list_of_ports() : {} {
	<LPAREN> port() ( <COMMA> port() )* <RPAREN>
}

void list_of_port_declarations() : {} {
	<LPAREN> [(attribute_instance())* ansi_port_declaration() ( <COMMA> (attribute_instance())* ansi_port_declaration())* ] <RPAREN>
}

void port_declaration() : {} {
	(attribute_instance())*
		( 
		inout_declaration()
		| input_declaration()
		| output_declaration()
		| ref_declaration()
		| interface_port_declaration()
		)
}

void port() : {} {
	[ port_expression() ]
	| "." identifier() <LPAREN> [ port_expression() ] <RPAREN>
}

void port_expression() : {} {
	port_reference()
	| "{" port_reference() ( <COMMA> port_reference())* "}"
}

void port_reference() : {} {
	identifier() constant_select()
}

void port_direction() : {} {
	<INPUT> | <OUTPUT> | <INOUT> | <REF>
}

void net_port_header() : {} {
	[ port_direction() ] net_port_type()
}

void variable_port_header() : {} {
	[ port_direction() ] variable_port_type()
}

void interface_port_header() : {} {
	identifier() [ "." identifier() ]
	| <INTERFACE> [ "." identifier() ]
}

void ansi_port_declaration() : {} {
	// FIXME: net_port_header() can expand as ""
	// [ net_port_header() | interface_port_header() ] identifier() (unpacked_dimension())*
	[ interface_port_header() ] identifier() (unpacked_dimension())*
	| [ variable_port_header() ] identifier() (variable_dimension())* [ <EQ_1> constant_expression() ]
	
	// FIXME: net_port_header() can expand as ""
	// CHG: expression can expand to "", so remove []
	// | [ net_port_header() | variable_port_header() ] "." identifier() <LPAREN> [ expression() ] <RPAREN>
	| [ variable_port_header() ] "." identifier() <LPAREN> expression() <RPAREN>
}

/****************************************************************************
 * A.1.4 Module items
 ****************************************************************************/
void module_common_item() : {} {
	module_or_generate_item_declaration()
	module_interface_program_instantiation()
	| concurrent_assertion_item()
// FIXME: bind_directive isn't distinguishable	| bind_directive()
	| continuous_assign()
	| net_alias()
	| initial_construct()
	| final_construct()
	| always_construct()
	| loop_generate_construct()
	| conditional_generate_construct()
}

void module_item() : {} {
	port_declaration() <SEMICOLON>
	| non_port_module_item()
}

void module_or_generate_item() : {} {
	(attribute_instance())* 
		(
			parameter_override()
			// FIXME: undistinguishable | gate_instantiation()
			// FIXME: undistinguishable | udp_instantiation()
			| module_interface_program_instantiation()
			| module_common_item()
		)
}

void module_or_generate_item_declaration() : {} {
	package_or_generate_item_declaration() 
	| genvar_declaration()
	// | clocking_declaration()
	// | <T_DEFAULT> <CLOCKING> identifier() <SEMICOLON>
	| [ <T_DEFAULT> ] <CLOCKING> 
		(
			LOOKAHEAD(2) [ identifier() ] clocking_event() <SEMICOLON>
			( clocking_item() )*
			<ENDCLOCKING> [ ":" identifier() ]
			| identifier() <SEMICOLON>
		)
}

void non_port_module_item() : {} {
  (
	generate_region()
	| module_or_generate_item()
	| specify_block()
	| (attribute_instance())* specparam_declaration()
	| program_declaration()
	| module_declaration()
//	| interface_declaration() FIXME:
	| timeunits_declaration()
  )
}

void parameter_override() : {} {
	<DEFPARAM> list_of_defparam_assignments() <SEMICOLON>
}

void bind_directive() : {} {
	// CHG: reorganize
	<BIND> 
	(
		identifier() [":" bind_target_instance_list()] |
		bind_target_instance()
	)	
	bind_instantiation() <SEMICOLON>
}

void bind_target_scope() : {} {
	identifier()
}

void bind_target_instance() : {} {
	hierarchical_identifier() constant_bit_select()
}

void bind_target_instance_list() :
{
}
{
	bind_target_instance() (<COMMA> bind_target_instance())*
}

void bind_instantiation() : {} {
	module_interface_program_instantiation()
}

/****************************************************************************
 * A.1.5 Configuration source text
 ****************************************************************************/
void config_declaration() :
{
}
{
	<CONFIG> identifier() <SEMICOLON>
	design_statement()
	(config_rule_statement())*
	<ENDCONFIG> [ ":" identifier() ]
}

void design_statement() :
{
}
{
	<DESIGN> ( [ LOOKAHEAD(2) identifier() "." ] identifier() )* <SEMICOLON>
}

void config_rule_statement() : {} {
	(
		<T_DEFAULT> liblist_clause() |
		(inst_clause() | cell_clause()) (liblist_clause() | use_clause())
	) <SEMICOLON>
}

void inst_clause() : {} {
	<INSTANCE> inst_name()
}

void inst_name() : {} {
	identifier() ( "." identifier() )*
}

void cell_clause() : {} {
	<CELL> [ LOOKAHEAD(2) identifier() "." ] identifier()
}

void liblist_clause() : {} {
	<LIBLIST> (identifier())*
}

void use_clause() : {} {
	<USE> [ LOOKAHEAD(2) identifier() "." ] identifier() [ ":" <CONFIG> ]
}
	
/****************************************************************************
 * A.1.6 Interface items
 ****************************************************************************/

void interface_or_generate_item() : {} {
	(attribute_instance())* 
	(
		module_common_item()
		| modport_declaration()
		| (attribute_instance())* extern_tf_declaration()
	)
}

void extern_tf_declaration() : {} {
	// CHG: reorganize
	<EXTERN>
	(
		method_prototype() |
		<FORKJOIN> task_prototype() 	 
	) <SEMICOLON>
}

void interface_item() : {} {
  (
	port_declaration() <SEMICOLON>
	| non_port_interface_item()
  )
}

void non_port_interface_item() : {} {
  (
	generate_region()
	| interface_or_generate_item()
	| program_declaration()
//	| interface_declaration() FIXME:
	| timeunits_declaration()
  )
}

/****************************************************************************
 * A.1.7 Program items
 ****************************************************************************/
void program_item() : {} {
  (
	port_declaration() <SEMICOLON>
	| non_port_program_item()
  )
}

void non_port_program_item() : {} {
	((attribute_instance())* 
		(
		continuous_assign()
		| module_or_generate_item_declaration()
		| initial_construct()
		| final_construct()
		| concurrent_assertion_item()
		| timeunits_declaration()
		)
	)
	| program_generate_item()
}

void program_generate_item() : {} {
  (
	loop_generate_construct()
	| conditional_generate_construct()
	| generate_region()
  )
}

/****************************************************************************
 * A.1.8 Class items
 ****************************************************************************/
void class_item() :
{
}
{
	((attribute_instance())* 
		class_property()
		| class_method()
		// FIXME: | class_constraint()
		| LOOKAHEAD(2) class_declaration()
		| timeunits_declaration()
		| covergroup_declaration()
	)
	| <SEMICOLON>
}

void class_property() : {} {
	// CHG: reorder
	<CONST> (class_item_qualifier())* data_type() identifier() [ <EQ_1> constant_expression() ] <SEMICOLON>
	| (property_qualifier())* data_declaration()
}

void class_method() : {} {
/*
  { method_qualifier } task_declaration
| { method_qualifier } function_declaration
| extern { method_qualifier } method_prototype ;
| { method_qualifier } class_constructor_declaration
| extern { method_qualifier } class_constructor_prototype
 */
	[<EXTERN>] (method_qualifier())*
		( 
			(LOOKAHEAD(3) method_prototype() <SEMICOLON> | LOOKAHEAD(3) class_constructor_prototype()) 
			| (task_declaration() | function_declaration() | class_constructor_declaration())
		)
}

void class_constructor_prototype() : {} {
    // CHG: tf_port_list() can expand to "", so remove []
	<FUNCTION> <NEW> <LPAREN> tf_port_list() <RPAREN> <SEMICOLON>
}


/** FIXME:
void class_constraint() : {} {
  (
	LOOKAHEAD(3) constraint_prototype()
	| LOOKAHEAD(3) constraint_declaration()
  )
}
 */

void class_item_qualifier() : {} {
	<STATIC> | <PROTECTED> | <LOCAL>
}

void property_qualifier() : {} {
	random_qualifier()	| class_item_qualifier()
}

void random_qualifier() : {} {
	<RAND> | <RANDC>
}

void method_qualifier () : {} {
	<VIRTUAL> | class_item_qualifier()
}

void method_prototype() : {} {
	task_prototype() | function_prototype()
}

void class_constructor_declaration() : {} {
	// CHG: tf_port_list can expand to "", so remove []
	<FUNCTION> [ class_scope() ] <NEW> [ <LPAREN> tf_port_list() <RPAREN> ] <SEMICOLON>
	(block_item_declaration())*
	[ <SUPER> "." <NEW> [ <LPAREN> list_of_arguments() <RPAREN> ] <SEMICOLON> ]
	(function_statement_or_null())*
	<ENDFUNCTION> [ ":" <NEW> ]
}

/****************************************************************************
 * A.1.9 Constraints
 ****************************************************************************/
 
/** FIXME:
void constraint_declaration() : {} {
	[ <STATIC> ] <CONSTRAINT> identifier() constraint_block()
}

void constraint_prototype() : {} {
	[ <STATIC> ] <CONSTRAINT> identifier() <SEMICOLON>
}

void constraint_block() : {} {
	"{" ( constraint_block_item() )* "}"
}

void constraint_block_item() : {} {
	<SOLVE> identifier_list() <BEFORE> identifier_list() <SEMICOLON>
	| constraint_expression()
}

void constraint_expression() : {} {
	expression_or_dist() <SEMICOLON>
	| expression() ("->") constraint_set()
	| <IF> <LPAREN> expression() <RPAREN> constraint_set() [ <ELSE> constraint_set() ]
	| <FOREACH> <LPAREN> identifier() [ loop_variables() ] <RPAREN> constraint_set()
}

void constraint_set() : {} {
	constraint_expression()
	| "{" ( constraint_expression() )* "}"
}

void dist_list() : {} {
	dist_item() ( <COMMA> dist_item() )*
}

void dist_item() : {} {
	value_range() [ dist_weight() ]
}

void dist_weight() : {} {
	":=" expression()
	| ":/" expression()
}


void extern_constraint_declaration() : {} {
	[ <STATIC> ] <CONSTRAINT> class_scope() identifier() constraint_block()
}
 */

void identifier_list() :
{
}
{
	identifier() ( <COMMA> identifier() )*
}

/****************************************************************************
 * A.1.10 Package items
 ****************************************************************************/
void package_item() :
{
}
{
  (
	package_or_generate_item_declaration() 
	| anonymous_program()
	| timeunits_declaration()
  )
}

void package_or_generate_item_declaration() :
{
}
{
  (
	net_declaration()
	| data_declaration()
	| task_declaration()
	| function_declaration()
	| dpi_import_export()
	// FIXME: | extern_constraint_declaration()
	| class_declaration()
	| class_constructor_declaration()
	| parameter_declaration() <SEMICOLON>
	| local_parameter_declaration()
	| covergroup_declaration()
	| overload_declaration()
	| concurrent_assertion_item_declaration()
	| <SEMICOLON>
  )
}

void anonymous_program() :
{
}
{
	<PROGRAM>  <SEMICOLON> (anonymous_program_item())* <ENDPROGRAM>
}

void anonymous_program_item() :
{
}
{
  (
	task_declaration()
	| function_declaration()
	| class_declaration()
	| covergroup_declaration()
	| class_constructor_declaration()
	| <SEMICOLON>
  )
}

/****************************************************************************
 * A.2 Declarations
 ****************************************************************************/
 
/********************************************************************
 * A.2.1 Declaration types
 ********************************************************************/

/********************************************************************
 * A.2.1.1 Module parameter declarations
 ********************************************************************/
void local_parameter_declaration() : {} {
	<LOCALPARAM> 
	(
		<TYPE> list_of_type_assignments()
		| data_type_or_implicit() list_of_param_assignments() 
	) <SEMICOLON>
}

void parameter_declaration() : {} {
	<PARAMETER> 
	(
		<TYPE> list_of_type_assignments()
		| data_type_or_implicit() list_of_param_assignments()
	)
}

void specparam_declaration() :
{
}
{
	<SPECPARAM> [ packed_dimension() ] list_of_specparam_assignments() <SEMICOLON>
}

/********************************************************************
 * A.2.1.2 Port declarations 
 ********************************************************************/
 
void inout_declaration() :
{
}
{
	<INOUT> net_port_type() list_of_port_identifiers()
}

void input_declaration() : {} {
	<INPUT> 
	(
		variable_port_type() list_of_variable_identifiers()
		| net_port_type() list_of_port_identifiers()
	)
}

void output_declaration() : {} {
	<OUTPUT> 
	(
		net_port_type() list_of_port_identifiers()
		| variable_port_type() list_of_variable_port_identifiers()
	)
}

void interface_port_declaration() : {} {
	identifier() [ "." identifier() ] list_of_interface_identifiers() 
}

void ref_declaration() : {} {
	<REF> variable_port_type() list_of_port_identifiers()
}

/********************************************************************
 * A.2.1.3 Type declarations 
 ********************************************************************/
 
void data_declaration() : {} {
	[ <CONST> ] [ <VAR> ] [ lifetime() ] data_type_or_implicit() list_of_variable_decl_assignments() <SEMICOLON>
	<VIRTUAL> [ <INTERFACE> ] identifier() list_of_virtual_interface_decl() <SEMICOLON>
	
	| type_declaration()
	| package_import_declaration()
}

void package_import_declaration() : {} {
	<IMPORT> package_import_item() (<COMMA> package_import_item())* <SEMICOLON>
}

void package_import_item() : {} {
	identifier() "::" (identifier() | "*")
}

void genvar_declaration() : {} {
	<GENVAR> list_of_genvar_identifiers() <SEMICOLON>
}

void net_declaration() : {} {
	net_type() [ LOOKAHEAD(2) drive_strength() | LOOKAHEAD(2) charge_strength() ] [ <VECTORED> | <SCALARED> ]
	data_type_or_implicit() [ delay3() ] list_of_net_decl_assignments() <SEMICOLON>
}

void type_declaration() : {} {
  <TYPEDEF> 
  (
	( [ <ENUM> | <STRUCT> | <UNION> | <CLASS> ] 
	  | /* interface_instance_id */ identifier() "." identifier() 
	) identifier()
	| data_type() identifier() (variable_dimension())*
  )
  <SEMICOLON>
}

void lifetime() : {} {
	(<STATIC> | <AUTOMATIC>)
}


/********************************************************************
 * A.2.2 Declaration data types
 ********************************************************************/


/********************************************************************
 * A.2.2.1 Net and variable types  
 ********************************************************************/
 
void casting_type() : {} {
	/* FIXME: eliminate constant_primary() as a casting type to
	 * eliminate left recursion
	simple_type() | constant_primary() | signing()
	 */
	simple_type() | signing()
}

void data_type() : { } {
	integer_vector_type() [ signing() ] (packed_dimension())*
	| integer_atom_type() [ signing() ]
	| non_integer_type()
	| struct_union() [ <PACKED> [ signing() ] ] (struct_union_member() (struct_union_member())*)* (packed_dimension())*
	| <ENUM> [enum_base_type()] (enum_name_declaration() (<COMMA> enum_name_declaration())*)*
	| <STRING>
	| <CHANDLE>
	| <VIRTUAL> [ <INTERFACE> ] identifier()
	| [ class_scope() | package_scope() ] identifier() (packed_dimension())*
	| class_type()
	| <EVENT>
	| ps_identifier()
	| type_reference()
}

void data_type_or_implicit() : {} {
  (
	data_type()
	| [signing()] (packed_dimension())*
  )
}

void enum_base_type() : {} {
	integer_atom_type() [signing()]
	| integer_vector_type() [signing()] [packed_dimension()]
	| identifier() [packed_dimension()]
}

void enum_name_declaration() : {} {
	identifier() [ "[" integral_number() [ ":" integral_number() ] "]" ] [ <EQ_1> constant_expression() ]
}

void class_scope() : {} {
	class_type() "::"
}

void class_type() : {} {
	ps_identifier() [ parameter_value_assignment() ]
		( "::" identifier() [ parameter_value_assignment() ])*
}

void integer_type() : {} {
	integer_vector_type() | integer_atom_type()
}

void integer_atom_type() : {} {
	<BYTE> | <SHORTINT> | <INT> | <LONGINT> | <INTEGER> | <TIME>
}

void integer_vector_type() : {} {
	<BIT> | <LOGIC> | <REG>
}

void non_integer_type() : {} {
	<SHORTREAL> | <REAL> | <REALTIME>
}

void net_type() : {} {
	<SUPPLY0> | <SUPPLY1> | <TRI> | <TRIAND> | <TRIOR> | <TRIREG> |
	<TRI0> | <TRI1> | <UWIRE> | <WIRE> | <WAND> | <WOR>
}

void net_port_type() : {} {
	[net_type()] data_type_or_implicit()
}

void variable_port_type() : {} {
	var_data_type()
}

void var_data_type() : {} {
	data_type() | <VAR> data_type_or_implicit()
}

void signing() : {} {
	<SIGNED> | <UNSIGNED>
}

void simple_type() : {} {
	integer_type() | non_integer_type()

	// ps_parameter_identifier()	
	| 
	(
		LOOKAHEAD(2)  [ LOOKAHEAD(2) (identifier() | <UNIT>) "::" ] 
	    | ( LOOKAHEAD(2) identifier() [ "[" constant_expression() "]" ] "." )*
	) identifier()
	
	/*
	// ps_identifier()
	[ package_scope() ] identifier()
	
	// package_scope()
	(identifier() | <UNIT>) "::"
	 */
}

void struct_union_member() : {} { 
	(attribute_instance())* [random_qualifier()] data_type_or_void() list_of_variable_decl_assignments() <SEMICOLON>
}

void data_type_or_void() : {} {
	data_type() | <VOID>
}

void struct_union() : {} {
	<STRUCT> | <UNION> [ LOOKAHEAD(1) <TAGGED> ]
}

void type_reference() : {} {
	<TYPE> <LPAREN> (expression() | data_type()) <RPAREN>
}

/********************************************************************
 * A.2.2.2 Strengths  
 ********************************************************************/
 
void drive_strength() : {} {
	<LPAREN> 
		(
			strength0() <COMMA> (strength1() | <HIGHZ1>)
			| strength1() <COMMA> (strength0() | <HIGHZ0>)
			| <HIGHZ0> <COMMA> strength1() 
			| <HIGHZ1> <COMMA> strength0() 
		)
	<RPAREN>
}

void strength0() : {} {
	<SUPPLY0> | <STRONG0> | <PULL0> | <WEAK0>
}

void strength1() : {} {
	<SUPPLY1> | <STRONG1> | <PULL1> | <WEAK1>
}

void charge_strength() : {} {
	<LPAREN> (<SMALL> | <MEDIUM> | <LARGE>) <RPAREN>
}


/********************************************************************
 * A.2.2.3 Delays  
 ********************************************************************/
void delay3() : {} {
	<HASH>
	(
		delay_value()
		| <LPAREN> mintypmax_expression() [ <COMMA> mintypmax_expression() [ <COMMA> mintypmax_expression() ]] <RPAREN>
	)
}

void delay2() : {} {
	<HASH> 
	(
		delay_value() 
		| <LPAREN> mintypmax_expression() [ <COMMA> mintypmax_expression() ] <RPAREN>
  	)
}

void delay_value() : {} {
	// unsigned_number() && time_literal()
	unsigned_number() [ "." unsigned_number() ] 
		[
			time_unit()
			| <EXP> [ sign() ] unsigned_number()
		]
	| ps_identifier()
	
	/*
	// TAKEN: unsigned_number()
	// TAKEN: | time_literal()
	// TAKEN: | real_number()
	| ps_identifier()
	 */
}

/********************************************************************
 * A.2.3 Declaration lists  
 ********************************************************************/

void list_of_defparam_assignments() : {} {
	defparam_assignment() ( <COMMA> defparam_assignment())*
}

void list_of_genvar_identifiers() : {} {
	identifier() ( <COMMA> identifier())*
}

void list_of_interface_identifiers() : {} {
	identifier() ( unpacked_dimension())*
	( <COMMA> identifier() ( unpacked_dimension())* )*
}

void list_of_net_decl_assignments() : {} {
	net_decl_assignment() ( <COMMA> net_decl_assignment())*
}

void list_of_param_assignments() : {} {
	param_assignment() ( LOOKAHEAD(1) <COMMA> param_assignment() )*
}

void list_of_port_identifiers() : {} {
	identifier() ( unpacked_dimension())*
	( <COMMA> identifier() ( unpacked_dimension())* )*
}

void list_of_udp_port_identifiers() : {} {
	identifier()  (LOOKAHEAD(1) <COMMA> identifier())*
}

void list_of_specparam_assignments() : {} {
	specparam_assignment() ( <COMMA> specparam_assignment())*
}

void list_of_tf_variable_identifiers() : {} {
	identifier() ( variable_dimension())* [ <EQ_1> expression() ]
	( <COMMA> identifier() ( variable_dimension())* [ <EQ_1> expression() ] )*
}

void list_of_type_assignments() : {} {
	type_assignment() ( LOOKAHEAD(1) <COMMA> type_assignment())*
}

void list_of_variable_decl_assignments() : {} {
	variable_decl_assignment() ( <COMMA> variable_decl_assignment())*
}

void list_of_variable_identifiers() : {} {
	identifier() ( variable_dimension() )*
	( <COMMA> identifier() ( variable_dimension() )* )*
}

void list_of_variable_port_identifiers() : {} {
	identifier() ( variable_dimension())* [ <EQ_1> constant_expression() ]
	(<COMMA> identifier() (variable_dimension())* [<EQ_1> constant_expression()])*
}

void list_of_virtual_interface_decl() : {} {
	identifier() [ <EQ_1> /* interface_instance */ identifier() ]
	( <COMMA> identifier() [<EQ_1> /* interface_instance */ identifier()])*
}

/********************************************************************
 * A.2.4 Declaration assignments  
 ********************************************************************/

void defparam_assignment() : {} {
	hierarchical_parameter_identifier() <EQ_1> constant_mintypmax_expression()
}

void net_decl_assignment() : {} {
	identifier() (unpacked_dimension())* [ <EQ_1> expression() ]
}

void param_assignment() : {} {
	identifier() (unpacked_dimension())* <EQ_1> constant_param_expression()
}

void specparam_assignment() : {} {
	identifier() <EQ_1> constant_mintypmax_expression()
	| pulse_control_specparam()
}

void type_assignment() : {} {
	identifier() <EQ_1> data_type()
}

void pulse_control_specparam() : {} {
	<PATHPULSE> 
		(
			<EQ_1> <LPAREN> reject_limit_value() [ <COMMA> error_limit_value() ] <RPAREN>
			| specify_input_terminal_descriptor() "$" specify_output_terminal_descriptor()
				<EQ_1> <LPAREN> reject_limit_value() [ <COMMA> error_limit_value() ] <RPAREN>
		)
/*
	<PATHPULSE> <EQ_1> <LPAREN> reject_limit_value() [ <COMMA> error_limit_value() ] <RPAREN>
	| <PATHPULSE> specify_input_terminal_descriptor() "$" specify_output_terminal_descriptor()
		<EQ_1> <LPAREN> reject_limit_value() [ <COMMA> error_limit_value() ] <RPAREN>
 */
}

void error_limit_value() : {} {
	limit_value()
}

void reject_limit_value() : {} {
	limit_value()
}

void limit_value() : {} {
	constant_mintypmax_expression()
}

void variable_decl_assignment() : {} {
	/*
	identifier() ( variable_dimension() )* [ <EQ_1> expression() ]
	| identifier() "[" "]" [ <EQ_1> dynamic_array_new() ]
	| identifier() [ <EQ_1> class_new() ]
	| [ identifier() ] <EQ_1> <NEW> [ <LPAREN> list_of_arguments() <RPAREN> ]
	 */
	identifier()
		( 
			( variable_dimension() )* [ <EQ_1> expression() ]
			| "[" "]" [ <EQ_1> dynamic_array_new() ]
			| [ <EQ_1> <NEW> [<LPAREN> list_of_arguments() <RPAREN>] ]
		)
	| [ identifier() ] <EQ_1> <NEW> [ <LPAREN> list_of_arguments() <RPAREN> ]
}

void class_new() : {} {
	//  CHG: expression() can expand to "", so move ]
	// <NEW> [ <LPAREN> list_of_arguments() <RPAREN> | expression() ]
	// <NEW> [ <LPAREN> list_of_arguments() <RPAREN> ] expression()
	
	// FIXME: I think this leaves a hole
	<NEW> [<LPAREN> list_of_arguments() <RPAREN>]
}

void dynamic_array_new() : {} {
	<NEW> "[" expression() "]" [ <LPAREN> expression() <RPAREN> ]
}

/********************************************************************
 * A.2.5 Declaration ranges  
 ********************************************************************/
void unpacked_dimension() : {} {
	"[" constant_range() | constant_expression() "]"
}

void packed_dimension() : {} {
	"[" [constant_range()] "]"
}

void associative_dimension() : {} {
	"[" data_type() | "*" "]"
}

void variable_dimension() : {} {

	"["
		// unsized_dimension() implicit
		[
			constant_expression() [":" constant_expression()] // unpacked_dimension()
			(data_type() | "*")               // associative_dimension()
			"$" [ ":" constant_expression() ] // queue_dimension()
		]
	"]"
/*
	unsized_dimension()
	| unpacked_dimension()
	| associative_dimension()
	| queue_dimension()
 */
}

void queue_dimension() : {} {
	"[" "$" [ ":" constant_expression() ] "]"
}

void unsized_dimension() : {} {
	"[" "]"
}

/********************************************************************
 * A.2.6 Function declarations  
 ********************************************************************/
 
void function_data_type() : {} {
	data_type() | <VOID>
}

void function_data_type_or_implicit() : {} {
	function_data_type()
	| [ signing() ] ( packed_dimension() )*
}

void function_declaration() : {} {
	<FUNCTION> [ lifetime() ] function_body_declaration()
}

void function_body_declaration() : {} {
	function_data_type_or_implicit()
	[ identifier() "." | class_scope() ] identifier() <SEMICOLON>
	( tf_item_declaration() )*
	( function_statement_or_null() )*
	<ENDFUNCTION> [ ":" identifier() ]
	| function_data_type_or_implicit()
		// CHG: tf_port_list() can expand to "", so remove []
	[ identifier() "." | class_scope() ] identifier() <LPAREN> tf_port_list() <RPAREN> <SEMICOLON>
	( block_item_declaration() )*
	( function_statement_or_null() )*
	<ENDFUNCTION> [ ":" identifier() ]
}

void function_prototype() : {} {
	// CHG: tf_port_list() can expand to "", so remove []
	<FUNCTION> function_data_type() identifier() <LPAREN> tf_port_list() <RPAREN>
}

void dpi_import_export() : {} {
	<IMPORT> dpi_spec_string() 
		(
			[ dpi_function_import_property() ] [ c_identifier() <EQ_1> ] dpi_function_proto() <SEMICOLON>
			| [ dpi_task_import_property() ] [ c_identifier() <EQ_1> ] dpi_task_proto() <SEMICOLON>
		)
	| <EXPORT> dpi_spec_string() [ c_identifier() <EQ_1> ] 
		(
			<FUNCTION> identifier()
			| <TASK> identifier()
		)
	<SEMICOLON>
}

void dpi_spec_string() : {} {
	<DPI_C> | <DPI>
}

void dpi_function_import_property() : {} {
	<CONTEXT> | <PURE>
}

void dpi_task_import_property() : {} {
	<CONTEXT>
}

void dpi_function_proto() : {} {
	function_prototype()
}

void dpi_task_proto() : {} {
	task_prototype()
} 

/********************************************************************
 * A.2.7 Task declarations  
 ********************************************************************/
void task_declaration() : {} {
	<TASK> [ lifetime() ] task_body_declaration()
}

void task_body_declaration() : {} {
	[ identifier() "." | class_scope() ] identifier()
		(
			<SEMICOLON> ( tf_item_declaration() )*
			| <LPAREN> tf_port_list() <RPAREN> <SEMICOLON> ( block_item_declaration() )*
		)
		( statement_or_null() )*
	<ENDTASK> [ ":" identifier() ]
}

void tf_item_declaration() : {} {
	block_item_declaration()
	| tf_port_declaration()
}

void tf_port_list() : {} {
	tf_port_item() ( <COMMA> tf_port_item() )*
}

void tf_port_item() : {} {
	( attribute_instance() )*
		[ tf_port_direction() ] [ <VAR> ] data_type_or_implicit()
		[ identifier() ( variable_dimension() )* [ <EQ_1> expression() ] ]
}

void tf_port_direction() : {} {
	port_direction() | <CONST> <REF>
}

void tf_port_declaration() : {} {
	( attribute_instance() )* tf_port_direction() [ <VAR> ] data_type_or_implicit() list_of_tf_variable_identifiers() <SEMICOLON>
}

void task_prototype() : {} {
	// CHG: tf_port_list() can expand to "", so remove []
	<TASK> identifier() <LPAREN> tf_port_list() <RPAREN>
}

/********************************************************************
 * A.2.8 Block item declarations  
 ********************************************************************/
void block_item_declaration() : {} {
	(attribute_instance())* 
		(
			data_declaration()
			| local_parameter_declaration()
			| parameter_declaration() <SEMICOLON>
			| overload_declaration()
		)
}

void overload_declaration() : {} {
	<BIND> overload_operator() <FUNCTION> data_type() identifier() <LPAREN> overload_proto_formals() <RPAREN> <SEMICOLON>
}

void overload_operator() : {} {
	// FIXME: decide what mangled characters are
	(<PLUS> | "++" | "�" | "��" | "*" | "**" | "/" | "%" | <EQ_2> | <NE_1> | <LT> | <LE> | <GT> | <GE> | <EQ_1>)
}

void overload_proto_formals() : {} {
	data_type() ( <COMMA> data_type() )*
}

/********************************************************************
 * A.2.9 Interface declarations  
 ********************************************************************/
 
void modport_declaration() : {} {
	<MODPORT> modport_item() ( <COMMA> modport_item() )* <SEMICOLON>
}

void modport_item() : {} {
	identifier() <LPAREN> modport_ports_declaration() (<COMMA> modport_ports_declaration())* <RPAREN>
}

void modport_ports_declaration() : {} {
	(attribute_instance())* 
		(
			modport_simple_ports_declaration()
			| modport_tf_ports_declaration()
			| modport_clocking_declaration()
		)
}

void modport_clocking_declaration() : {} {
	<CLOCKING> identifier()
}

void modport_simple_ports_declaration() : {} {
	port_direction() modport_simple_port() ( LOOKAHEAD(1) <COMMA> modport_simple_port())*
}

void modport_simple_port() : {} {
	identifier()
	// CHG: expression() can expand to "", so remove[]
	| "." identifier() <LPAREN> expression() <RPAREN>
}

void modport_tf_ports_declaration() : {} {
	import_export() modport_tf_port() ( LOOKAHEAD(1) <COMMA> modport_tf_port())*
}

void modport_tf_port() : {} {
	method_prototype()
	| identifier()
}

void import_export() : {} {
	<IMPORT> | <EXPORT>
}

/********************************************************************
 * A.2.10 Assertion declarations
 ********************************************************************/

void concurrent_assertion_item() : {} {
	[ identifier() ":" ] concurrent_assertion_statement()
}

void concurrent_assertion_statement() : {} {
	assert_property_statement()
	| assume_property_statement()
	| cover_property_statement()
}

void assert_property_statement() : {} {
	<ASSERT> <PROPERTY> <LPAREN> property_spec() <RPAREN> action_block()
}

void assume_property_statement() : {} {
	<ASSUME> <PROPERTY> <LPAREN> property_spec() <RPAREN> <SEMICOLON>
}

void cover_property_statement() : {} {
	<COVER> <PROPERTY> <LPAREN> property_spec() <RPAREN> statement_or_null()
}

void expect_property_statement() : {} {
	<EXPECT> <LPAREN> property_spec() <RPAREN> action_block()
}

void property_instance() : {} {
	// CHG: list_of_arguments() can expand to "", so remove []
	ps_identifier() [ <LPAREN> list_of_arguments() <RPAREN> ]
}

void concurrent_assertion_item_declaration() : {} {
	property_declaration()
	| sequence_declaration()
}

void property_declaration() : {} {
	// CHG: tf_port_list() can expand to "", so remove []
	<PROPERTY> identifier() [ <LPAREN> tf_port_list() <RPAREN> ] <SEMICOLON>
	(assertion_variable_declaration())*
	property_spec() <SEMICOLON>
	<ENDPROPERTY> [ ":" identifier() ]
}

void property_spec() : {} {
	[clocking_event() ] [ <DISABLE> <IFF> <LPAREN> expression_or_dist() <RPAREN> ] property_expr()
}

void property_expr() : {} {
    /* CHG: eliminate left recursion
	sequence_expr()
	| <LPAREN> property_expr() <RPAREN>
	| <NOT> property_expr()
	| property_expr() <OR> property_expr()
	| property_expr() <AND> property_expr()
	| sequence_expr() "|->" property_expr()
	| sequence_expr() "|=>" property_expr()
	| <IF> <LPAREN> expression_or_dist() <RPAREN> property_expr() [ <ELSE> property_expr() ]
	| property_instance()
	| clocking_event() property_expr()
	 */
  (
	sequence_expr() [("|->" | "|=>") property_expr()]
	| <LPAREN> property_expr() <RPAREN>
	| <NOT> property_expr()
	| <IF> <LPAREN> expression_or_dist() <RPAREN> property_expr() [ <ELSE> property_expr() ]
	| property_instance()
	| clocking_event() property_expr()
  ) [  (
			<OR> property_expr()  |
			<AND> property_expr()
  		) property_expr()]
}

void property_expr_2() : {} {
  (
	<OR> property_expr()  |
	<AND> property_expr()
  ) property_expr()

}

void sequence_declaration() : {} {
	// CHG: tf_port_list() can expand to "", so remove []
	<SEQUENCE> identifier() [ <LPAREN> tf_port_list() <RPAREN> ] <SEMICOLON>
	(assertion_variable_declaration())*
	sequence_expr() <SEMICOLON>
	<ENDSEQUENCE> [ ":" identifier() ]
}

void sequence_expr() : {} {
	/* CHG: eliminate left recursion
	cycle_delay_range() sequence_expr() ( cycle_delay_range() sequence_expr())*
	| sequence_expr() cycle_delay_range() sequence_expr() (cycle_delay_range() sequence_expr())*
	| expression_or_dist() [ boolean_abbrev() ]
	| <LPAREN> expression_or_dist() (<COMMA> sequence_match_item())* <RPAREN> [ boolean_abbrev() ]
	| sequence_instance() [ sequence_abbrev() ]
	| <LPAREN> sequence_expr() (<COMMA> sequence_match_item())* <RPAREN> [ sequence_abbrev() ]
	| sequence_expr() <AND> sequence_expr()
	| sequence_expr() <INTERSECT> sequence_expr()
	| sequence_expr() <OR> sequence_expr()
	| <FIRST_MATCH> <LPAREN> sequence_expr() (<COMMA> sequence_match_item())* <RPAREN>
	| expression_or_dist() <THROUGHOUT> sequence_expr()
	| sequence_expr() <WITHIN> sequence_expr()
	| clocking_event() sequence_expr()
	 */
  (
	cycle_delay_range() sequence_expr() ( cycle_delay_range() sequence_expr())*
	| expression_or_dist() [ boolean_abbrev() ]
	| <LPAREN>
		( 
			expression_or_dist() (<COMMA> sequence_match_item())* <RPAREN> [ boolean_abbrev() ]
			| sequence_expr() (<COMMA> sequence_match_item())* <RPAREN> [ sequence_abbrev() ]
		)
	| sequence_instance() [ sequence_abbrev() ]
	| <FIRST_MATCH> <LPAREN> sequence_expr() (<COMMA> sequence_match_item())* <RPAREN>
	| expression_or_dist() <THROUGHOUT> sequence_expr()
	| clocking_event() sequence_expr()
  ) [ sequence_expr_2() ]
}

void sequence_expr_2() : {} {
  (
	cycle_delay_range() sequence_expr() (cycle_delay_range() sequence_expr())*
	| <AND> sequence_expr()
	| <INTERSECT> sequence_expr()
	| <OR> sequence_expr()
	| <WITHIN> sequence_expr()
  ) sequence_expr()
}

void cycle_delay_range() : {} {
	"##" 
		(
			integral_number()
			| identifier()
			| <LPAREN> constant_expression() <RPAREN>
			| [ cycle_delay_const_range_expression() ]
		)
}

void sequence_method_call() : {} {
	sequence_instance() "." identifier()
}

void sequence_match_item() : {} {
	operator_assignment()
	| inc_or_dec_expression()
	| subroutine_call()
}

void sequence_instance() : {} {
	// CHG: list_of_arguments() can expand to "", so remove []
	ps_identifier() [ <LPAREN> list_of_arguments() <RPAREN> ]
}

void formal_list_item() : {} {
	identifier() [ <EQ_1> actual_arg_expr() ]
}

void list_of_formals() : {} {
	formal_list_item() ( <COMMA> formal_list_item() )*
}

void actual_arg_expr() : {} {
	event_expression()
	| "$"
}

void boolean_abbrev() : {} {
	consecutive_repetition()
	| non_consecutive_repetition()
	| goto_repetition()
}

void sequence_abbrev() : {} {
	consecutive_repetition()
}

void consecutive_repetition() : {} {
	"[*" const_or_range_expression() "]"
}

void non_consecutive_repetition() : {} {
	"[=" const_or_range_expression() "]"
}

void goto_repetition() : {} {
	"[->" const_or_range_expression() "]"
}

void const_or_range_expression() : {} {
	/*
	constant_expression()
	| cycle_delay_const_range_expression()
	 */
	constant_expression() [":" (constant_expression() | "$")]
}

void cycle_delay_const_range_expression() : {} {
	constant_expression() ":" (constant_expression() | "$")
}

void expression_or_dist() : {} {
	expression() // FIXME: [ <DIST> "{" dist_list() "}" ]
}

void assertion_variable_declaration() : {} {
	var_data_type() list_of_variable_identifiers() <SEMICOLON>
}

 
/********************************************************************
 * A.2.11 Covergroup declarations  
 ********************************************************************/
void covergroup_declaration() : {} {
	// CHG: tf_port_list() can expand to "", so remove []
	<COVERGROUP> identifier() [ <LPAREN> tf_port_list() <RPAREN> ] [ coverage_event() ] <SEMICOLON>
	( coverage_spec_or_option() )*
	<ENDGROUP> [ ":" identifier() ]
}

void coverage_spec_or_option() : {} {
	( attribute_instance() )* 
		(
			coverage_spec()
			| coverage_option() <SEMICOLON>
		)
}

void coverage_option() : {} {
	<OPTION> "." identifier() <EQ_1> expression()
	| <TYPE_OPTION> "." identifier() <EQ_1> expression()
}

void coverage_spec() : {} {
	cover_point()
	| cover_cross()
}

void coverage_event() : {} {
	clocking_event()
	| "@@" <LPAREN> block_event_expression() <RPAREN>
}

void block_event_expression() : {} {
	// CHG: eliminate left recursion
	// A -> Aa | b
	//
	// A  -> bA'
	// A' -> aA' | eta
	//
	// b  -> (<BEGIN> ... | <END> ...)
	// a  -> (<OR> block_event_expression())
	//
	// 
	/*
	block_event_expression() <OR> block_event_expression()
	| <BEGIN> hierarchical_btf_identifier()
	| <END> hierarchical_btf_identifier()
	 */
	(<BEGIN> hierarchical_btf_identifier()
		| <END> hierarchical_btf_identifier()
	) [block_event_expression_2()]
}

void block_event_expression_2() : {} {
	<OR> block_event_expression() block_event_expression_2()
}


void hierarchical_btf_identifier() : {} {
	hierarchical_tf_identifier()
	| hierarchical_identifier() [ [ class_scope() ] identifier()]
}

void cover_point() : {} {
	[ identifier() ":" ] <COVERPOINT> expression() [ <IFF> <LPAREN> expression() <RPAREN> ] bins_or_empty()
}

void bins_or_empty() : {} {
	"{" (attribute_instance() )* ( bins_or_options() <SEMICOLON> )*  "}"
	| <SEMICOLON>
}

void bins_or_options() : {} {
	coverage_option()
	// CHG: expression can expand to "", so remove []
	| [ <WILDCARD> ] bins_keyword() identifier() [ "[" [expression()] "]" ] <EQ_1> 
		(
			"{" open_range_list() "}"
			| trans_list() 
		) [ <IFF> <LPAREN> expression() <RPAREN> ]
	// CHG: expression can expand to "", so remove []
	| bins_keyword() identifier() 
		(
			[ "[" expression() "]" ] <EQ_1> <T_DEFAULT>
			| <EQ_1> <T_DEFAULT> <SEQUENCE> 
		) [ <IFF> <LPAREN> expression() <RPAREN> ]
}

void bins_keyword () : {} {
	<BINS> | <ILLEGAL_BINS> | <IGNORE_BINS>
}

void range_list() : {} {
	value_range() ( <COMMA> value_range() )*
}

void trans_list() : {} {
	<LPAREN> trans_set() <RPAREN> ( <COMMA> <LPAREN> trans_set() <RPAREN> )*
}

void trans_set() : {} {
	trans_range_list() ( "=>" trans_range_list() )*
}

void trans_range_list() : {} {
	trans_item() [ "[" 
		(
			"*" repeat_range()
			| "->" repeat_range()
			| <EQ_1> repeat_range()
		)
	"]"]
}

void trans_item() : {} {
	range_list()
}

void repeat_range() : {} {
	expression() [":" expression()]
}

void cover_cross() : {} {
	[ /*cover_point_*/ identifier() ":" ] <CROSS> list_of_coverpoints() [ <IFF> <LPAREN> expression() <RPAREN> ]
	select_bins_or_empty()
}

void list_of_coverpoints() : {} {
	cross_item() <COMMA> cross_item() ( <COMMA> cross_item() )*
}

void cross_item() : {} {
	identifier()
}

void select_bins_or_empty() : {} {
	"{" ( bins_selection_or_option() <SEMICOLON> )* "}"
	| <SEMICOLON>
}

void bins_selection_or_option() : {} {
	( attribute_instance() )* 
		(
			coverage_option()
			| bins_selection()
		)
}

void bins_selection() : {} {
	bins_keyword() identifier() <EQ_1> select_expression() [ <IFF> <LPAREN> expression() <RPAREN> ]
}

void select_expression() : {} {
    /* CHG: remove left recursion
	select_condition()
	| "!" select_condition()
	| select_expression() "&&" select_expression()
	| select_expression() "||" select_expression()
	| <LPAREN> select_expression() <RPAREN>
	 */
  (
	select_condition()
	| "!" select_condition()
	| <LPAREN> select_expression() <RPAREN>
  ) [select_expression_2()]
}

void select_expression_2() : {} {
  (
	  "&&" select_expression()
	| "||" select_expression()
  ) select_expression()
}


void select_condition() : {} {
	<BINSOF> <LPAREN> bins_expression() <RPAREN> [ <INTERSECT> "{" open_range_list() "}" ]
}

void bins_expression() : {} {
	identifier() [ "." /*bin_*/ identifier() ]
}

void open_range_list() : {} {
	open_value_range() ( <COMMA> open_value_range() )*
}

void open_value_range() : {} {
	value_range()
}

/****************************************************************************
 * A.3 Primitive instances
 ****************************************************************************/

/********************************************************************
 * A.3.1 Primitive instantiation and instances
 ********************************************************************/

void gate_instantiation() : {} {
	cmos_switchtype() [delay3()] cmos_switch_instance() ( <COMMA> cmos_switch_instance() )* <SEMICOLON>
	| enable_gatetype() [drive_strength()] [delay3()] enable_gate_instance() ( <COMMA> enable_gate_instance() )* <SEMICOLON>
	| mos_switchtype() [delay3()] mos_switch_instance() ( <COMMA> mos_switch_instance() )* <SEMICOLON>
	| n_input_gatetype() [drive_strength()] [delay2()] n_input_gate_instance() ( <COMMA> n_input_gate_instance() )* <SEMICOLON>
	| n_output_gatetype() [drive_strength()] [delay2()] n_output_gate_instance() ( <COMMA> n_output_gate_instance() )* <SEMICOLON>
	| pass_en_switchtype() [delay2()] pass_enable_switch_instance() ( <COMMA> pass_enable_switch_instance() )* <SEMICOLON>
	| pass_switchtype() pass_switch_instance() ( <COMMA> pass_switch_instance() )* <SEMICOLON>
	| <PULLDOWN> [pulldown_strength()] pull_gate_instance() ( <COMMA> pull_gate_instance() )* <SEMICOLON>
	| <PULLUP> [pullup_strength()] pull_gate_instance() ( <COMMA> pull_gate_instance() )* <SEMICOLON>
}

void cmos_switch_instance() : {} {
	[ name_of_instance() ] <LPAREN> output_terminal() <COMMA> input_terminal() <COMMA> ncontrol_terminal() <COMMA> pcontrol_terminal() <RPAREN>
}

void enable_gate_instance() : {} {
	[ name_of_instance() ] <LPAREN> output_terminal() <COMMA> input_terminal() <COMMA> enable_terminal() <RPAREN>
}

void mos_switch_instance() : {} {
	[ name_of_instance() ] <LPAREN> output_terminal() <COMMA> input_terminal() <COMMA> enable_terminal() <RPAREN>
}

void n_input_gate_instance() : {} {
	[ name_of_instance() ] <LPAREN> output_terminal() <COMMA> input_terminal() ( <COMMA> input_terminal() )* <RPAREN>
}

void n_output_gate_instance() : {} {
	[ name_of_instance() ] <LPAREN> output_terminal() ( LOOKAHEAD(1) <COMMA> output_terminal() )* <COMMA> input_terminal() <RPAREN>
}

void pass_switch_instance() : {} {
	[ name_of_instance() ] <LPAREN> inout_terminal() <COMMA> inout_terminal() <RPAREN>
}

void pass_enable_switch_instance() : {} {
	[ name_of_instance() ] <LPAREN> inout_terminal() <COMMA> inout_terminal() <COMMA> enable_terminal() <RPAREN>
}

void pull_gate_instance() : {} {
	[ name_of_instance() ] <LPAREN> output_terminal() <RPAREN>
}


/********************************************************************
 * A.3.2 Primitive strengths
 ********************************************************************/
void pulldown_strength() : {} {
	<LPAREN> 
		(strength0() [<COMMA> strength1()] <RPAREN>
		| strength1() <COMMA> strength0() <RPAREN>
		)
}

void pullup_strength() : {} {
	<LPAREN> 
		(strength0() <COMMA> strength1() <RPAREN>
		| strength1() [<COMMA> strength0()] <RPAREN>
		)
}


/********************************************************************
 * A.3.3 Primitive terminals
 ********************************************************************/

void enable_terminal() : {} {
	expression()
}

void inout_terminal() : {} {
	net_lvalue()
}

void input_terminal() : {} {
	expression()
}

void ncontrol_terminal() : {} {
	expression()
}

void output_terminal() : {} {
	net_lvalue()
}

void pcontrol_terminal() : {} {
	expression()
}

/********************************************************************
 * A.3.4 Primitive gate and switch types
 ********************************************************************/
void cmos_switchtype() : {} {
	<CMOS> | <RCMOS>
}

void enable_gatetype() : {} {
	<BUFIF0> | <BUFIF1> | <NOTIF0> | <NOTIF1>
}

void mos_switchtype() : {} {
	<NMOS> | <PMOS> | <RNMOS> | <RPMOS>
}

void n_input_gatetype() : {} {
	<AND> | <NAND> | <OR> | <NOR> | <XOR> | <XNOR>
}

void n_output_gatetype() : {} {
	<BUF> | <NOT>
}

void pass_en_switchtype() : {} {
	<TRANIF0> | <TRANIF1> | <RTRANIF1> | <RTRANIF0>
}

void pass_switchtype() : {} {
	<TRAN> | <RTRAN>
}


/****************************************************************************
 * A.4 Module, interface and generated instantiation
 ****************************************************************************/
 
/********************************************************************
 * A.4.1.1 Module instantiation
 ********************************************************************/
 
void parameter_value_assignment() : {} {
	// CHG: list_of_parameter_assignments can expand to "", so remove []
 	<HASH> <LPAREN> list_of_parameter_assignments() <RPAREN>
}
 
void list_of_parameter_assignments() : {} {
	ordered_parameter_assignment() ( <COMMA> ordered_parameter_assignment() )*
	| named_parameter_assignment() ( <COMMA> named_parameter_assignment() )*
}

void ordered_parameter_assignment() : {} {
	param_expression()
}

void named_parameter_assignment() : {} {
	// CHG: param_expression() can expand to "", so remove []
	"." identifier() <LPAREN> param_expression() <RPAREN>
}

void hierarchical_instance() : {} {
	// CHG: list_of_port_connections() can expand to "", so remove []
	name_of_instance() <LPAREN> list_of_port_connections() <RPAREN>
}

void name_of_instance() : {} {
	identifier() ( unpacked_dimension() )*
}

void list_of_port_connections() : {} {
	ordered_port_connection() ( <COMMA> ordered_port_connection() )*
	| named_port_connection() ( <COMMA> named_port_connection() )*
}

void ordered_port_connection() : {} {
	// CHG: expression() can expand to "", so remove []
	( attribute_instance() )* expression()
}

void named_port_connection() : {} {
	// CHG: expression() can expand to [], so remove []
	( attribute_instance() )* 
		(
			"." identifier() [ <LPAREN> expression() <RPAREN> ]
			| ".*"
		)
}

/********************************************************************
 * A.4.1.2 Interface instantiation
 ********************************************************************/
 
/********************************************************************
 * A.4.1.3 Program instantiation
 ********************************************************************/

void module_interface_program_instantiation() : {} {
	identifier() [ parameter_value_assignment() ] hierarchical_instance() (<COMMA> hierarchical_instance())* <SEMICOLON>
}

/********************************************************************
 * A.4.2 Generated instantiation
 ********************************************************************/

void module_or_interface_or_generate_item() : {} {
	module_or_generate_item()
	| interface_or_generate_item()
}

void generate_region() : {} {
	<GENERATE> ( module_or_interface_or_generate_item() )* <ENDGENERATE>
}

void loop_generate_construct() : {} {
	<FOR> <LPAREN> genvar_initialization() <SEMICOLON> genvar_expression() <SEMICOLON> genvar_iteration() <RPAREN>
	generate_block()
}

void genvar_initialization() : {} {
	[ <GENVAR> ] identifier() <EQ_1> constant_expression()
}

void genvar_iteration() : {} {
	identifier() 
		(
			assignment_operator() genvar_expression()
			| inc_or_dec_operator()
		)
	| inc_or_dec_operator() identifier()
}

void conditional_generate_construct() : {} {
	if_generate_construct()
	| case_generate_construct()
}

void if_generate_construct() : {} {
	<IF> <LPAREN> constant_expression() <RPAREN> generate_block_or_null() 
		[ <ELSE> generate_block_or_null() ]
}

void case_generate_construct() : {} {
	<CASE> <LPAREN> constant_expression() <RPAREN> case_generate_item() ( case_generate_item() )* <ENDCASE>
}

void case_generate_item() : {} {
	constant_expression() ( <COMMA> constant_expression())* ":" generate_block_or_null()
	| <T_DEFAULT> [ ":" ] generate_block_or_null()
}

void generate_block() : {} {
	module_or_interface_or_generate_item()
	| [ identifier() ":" ] <BEGIN> [ ":" identifier() ]
	( module_or_interface_or_generate_item() )*
	<END> [ ":" identifier() ]
}

void generate_block_or_null() : {} {
	generate_block() | <SEMICOLON>
}

/****************************************************************************
 * A.5 UDP declaration and instantiation
 ****************************************************************************/

/********************************************************************
 * A.5.1 UDP declaration
 ********************************************************************/

void udp_nonansi_declaration() : {} {
	( attribute_instance() )* <PRIMITIVE> identifier() <LPAREN> udp_port_list() <RPAREN> <SEMICOLON>
}

void udp_ansi_declaration() : {} {
	( attribute_instance() )* <PRIMITIVE> identifier() <LPAREN> udp_declaration_port_list() <RPAREN> <SEMICOLON>
}

void udp_declaration() : {} {
	udp_nonansi_declaration() udp_port_declaration() ( udp_port_declaration() )*
	udp_body()
	<ENDPRIMITIVE> [ ":" identifier() ]
	| udp_ansi_declaration()
	udp_body()
	<ENDPRIMITIVE> [ ":" identifier() ]
	| <EXTERN> (udp_nonansi_declaration() | udp_ansi_declaration()) 
	| ( attribute_instance() )* <PRIMITIVE> identifier() <LPAREN> ".*" <RPAREN> <SEMICOLON> ( udp_port_declaration() )*
	udp_body()
	<ENDPRIMITIVE> [ ":" identifier() ]
}

/********************************************************************
 * A.5.2 UDP ports
 ********************************************************************/
void udp_port_list() : {} {
	identifier() <COMMA> identifier() ( <COMMA> identifier() )*
}

void udp_declaration_port_list() : {} {
	udp_output_declaration() <COMMA> udp_input_declaration() ( <COMMA> udp_input_declaration() )*
}

void udp_port_declaration() : {} {
/*
	udp_output_declaration() <SEMICOLON>
	| udp_input_declaration() <SEMICOLON>
	| udp_reg_declaration() <SEMICOLON>
 */
	( attribute_instance() )* 
	(
		<OUTPUT> 
		(
			identifier()
			| <REG> identifier() [ <EQ_1> constant_expression() ]
		)
		| <INPUT> list_of_udp_port_identifiers()
		| <REG> identifier()
	)
}

void udp_output_declaration() : {} {
	( attribute_instance() )* <OUTPUT> 
		(
			identifier()
			| <REG> identifier() [ <EQ_1> constant_expression() ]
		)
}

void udp_input_declaration() : {} {
	( attribute_instance() )* <INPUT> list_of_udp_port_identifiers()
}

void udp_reg_declaration() : {} {
	( attribute_instance() )* <REG> identifier()
}

/********************************************************************
 * A.5.3 UDP body
 ********************************************************************/

void udp_body() : {} {
	combinational_body() | sequential_body()
}

void combinational_body() : {} {
	<TABLE> combinational_entry() ( combinational_entry() )* <ENDTABLE>
}

void combinational_entry() : {} {
	level_input_list() ":" output_symbol() <SEMICOLON>
}

void sequential_body() : {} {
	[ udp_initial_statement() ] <TABLE> sequential_entry() ( sequential_entry() )* <ENDTABLE>
}

void udp_initial_statement() : {} {
	<INITIAL> identifier() <EQ_1> init_val() <SEMICOLON>
}

void init_val() : {} {
	"1�b0" | "1�b1" | "1�bx" | "1�bX" | "1�B0" | "1�B1" | "1�Bx" | "1�BX" | "1" | "0"
}

void sequential_entry() : {} {
	seq_input_list() ":" current_state() ":" next_state() <SEMICOLON>
}

void seq_input_list() : {} {
	level_input_list() | edge_input_list()
}

void level_input_list() : {} {
	level_symbol() ( level_symbol() )*
}

void edge_input_list() : {} {
	( level_symbol() )* edge_indicator() ( level_symbol() )*
}

void edge_indicator() : {} {
	<LPAREN> level_symbol() level_symbol() <RPAREN> | edge_symbol()
}

void current_state() : {} {
	level_symbol()
}

void next_state() : {} {
	output_symbol() | "-"
}

void output_symbol() : {} {
	"0" | "1" | "x" | "X"
}

void level_symbol() : {} {
	<BIN4S_DIGIT>
}
	
void edge_symbol() : {} {
	"r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*"
}


/********************************************************************
 * A.5.4 UDP instantiation
 ********************************************************************/

void udp_instantiation() : {} {
	identifier() [ drive_strength() ] [ delay2() ] udp_instance() ( <COMMA> udp_instance() )* <SEMICOLON>
}

void udp_instance() : {} {
	[ name_of_instance() ] <LPAREN> output_terminal() <COMMA> input_terminal() ( <COMMA> input_terminal() )* <RPAREN>
}

/****************************************************************************
 * A.6 Behavioral statements
 ****************************************************************************/

/********************************************************************
 * A.6.1 Continuous assignment and net alias statements
 ********************************************************************/
void continuous_assign() : {} {
	<ASSIGN> 
		(
			[ drive_strength() ] [ delay3() ] list_of_net_assignments()
			| [ delay_control() ] list_of_variable_assignments()
		) 
	<SEMICOLON>
}

void list_of_net_assignments() : {} {
	net_assignment() ( <COMMA> net_assignment())*
}

void list_of_variable_assignments() : {} {
	variable_assignment() ( <COMMA> variable_assignment())*
}

void net_alias() : {} {
	<ALIAS> net_lvalue() <EQ_1> net_lvalue() (<EQ_1> net_lvalue())* <SEMICOLON>
}

void net_assignment() : {} {
	net_lvalue() <EQ_1> expression()
}

/********************************************************************
 * A.6.2 Procedural blocks and assignments
 ********************************************************************/

void initial_construct() : {} {
	<INITIAL> statement_or_null()
}

void always_construct() : {} {
	always_keyword() statement()
}

void always_keyword() : {} {
	<ALWAYS> | <ALWAYS_COMB> | <ALWAYS_LATCH> | <ALWAYS_FF>
}

void final_construct() : {} {
	<FINAL> function_statement()
}

void blocking_assignment() : {} {
	variable_lvalue() <EQ_1> delay_or_event_control() expression()
	| hierarchical_dynamic_array_variable_identifier() <EQ_1> dynamic_array_new()
	| [ implicit_class_handle() "." | class_scope() | package_scope() ] hierarchical_variable_identifier()
	select() <EQ_1> class_new()
	| operator_assignment()
}

void operator_assignment() : {} {
	variable_lvalue() assignment_operator() expression()
}

void assignment_operator() : {} {
	<EQ_1> | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | <LSE> | ">>=" | <LLSE> | ">>>="
}

void nonblocking_assignment() : {} {
	variable_lvalue() <LE> [ delay_or_event_control() ] expression()
}

void procedural_continuous_assignment() : {} {
	<ASSIGN> variable_assignment()
	| <DEASSIGN> variable_lvalue()
	| <FORCE> (variable_assignment() | net_assignment())
	| <RELEASE> (variable_lvalue() | net_lvalue()) 
}

void variable_assignment() : {} {
	variable_lvalue() <EQ_1> expression()
}

/********************************************************************
 * A.6.3 Parallel and sequential blocks
 ********************************************************************/
void action_block() : {} {
	statement_or_null()
	| [ statement() ] <ELSE> statement_or_null()
}

void seq_block() : {} {
	<BEGIN> [ ":" identifier() ] (block_item_declaration())* (statement_or_null())*
	<END> [ ":" identifier() ]
}

void par_block() : {} {
	<FORK> [ ":" identifier() ] (block_item_declaration())* (statement_or_null())*
	join_keyword() [ ":" identifier() ]
}

void join_keyword() : {} {
	<JOIN> | <JOIN_ANY> | <JOIN_NONE>
}

/********************************************************************
 * A.6.4 Statements
 ********************************************************************/
void statement_or_null() : {} {
	statement()
	| (attribute_instance())* <SEMICOLON>
}

void statement() : {} {
	[ identifier() ":" ] (attribute_instance())* statement_item()
}

void statement_item() : {} {
	blocking_assignment() <SEMICOLON>
	| nonblocking_assignment() <SEMICOLON>
	| procedural_continuous_assignment() <SEMICOLON>
	| case_statement()
	| conditional_statement()
	| inc_or_dec_expression() <SEMICOLON>
	| subroutine_call_statement()
	| disable_statement()
	| event_trigger()
	| loop_statement()
	| jump_statement()
	| par_block()
	| procedural_timing_control_statement()
	| seq_block()
	| wait_statement()
	| procedural_assertion_statement()
	| clocking_drive() <SEMICOLON>
	| randsequence_statement()
	| randcase_statement()
	| expect_property_statement()
}

void function_statement() : {} {
	statement()
}

void function_statement_or_null() : {} {
	function_statement()
	| (attribute_instance())* <SEMICOLON>
}

void variable_identifier_list() : {} {
	identifier() ( <COMMA> identifier())*
}

/********************************************************************
 * A.6.5 Timing control statements
 ********************************************************************/

void procedural_timing_control_statement() : {} {
	procedural_timing_control() statement_or_null()
}

void delay_or_event_control() : {} {
	delay_control()
	| event_control()
	| <REPEAT> <LPAREN> expression() <RPAREN> event_control()
}

void delay_control() : {} {
	<HASH> 
		(
			delay_value()
			| <LPAREN> mintypmax_expression() <RPAREN>
		)
}

void event_control() : {} {
	"@" 
		(
			hierarchical_event_identifier()
			| <LPAREN> (event_expression() | "*") <RPAREN>
			| sequence_instance()
		)
	| "@*"
}

void event_expression() : {} {
  (
	[ edge_identifier() ] expression() [ <IFF> expression() ]
	| sequence_instance() [ <IFF> expression() ]
  ) [event_expression_2()]
}

void event_expression_2() : {} {
  (
	  <OR> event_expression()
	| <COMMA> event_expression()
  ) event_expression()
}

void procedural_timing_control() : {} {
	delay_control()
	| event_control()
	| cycle_delay()
}

void jump_statement() : {} {
	// CHG: expression can expand to "", so remove []
	<RETURN> expression() <SEMICOLON>
	| <BREAK> <SEMICOLON>
	| <CONTINUE> <SEMICOLON>
}

void wait_statement() : {} {
	<WAIT> 
		(
			<LPAREN> expression() <RPAREN> statement_or_null()
			| <FORK> <SEMICOLON>
		)
	| <WAIT_ORDER> <LPAREN> hierarchical_identifier() ( <COMMA> hierarchical_identifier())* <RPAREN> action_block()
}

void event_trigger() : {} {
	"->" hierarchical_event_identifier() <SEMICOLON>
	| "->>" [ delay_or_event_control() ] hierarchical_event_identifier() <SEMICOLON>
}

void disable_statement() : {} {
	<DISABLE> 
		(
			hierarchical_task_identifier()
			| hierarchical_identifier()
			| <FORK>
		)
		<SEMICOLON>
}

/********************************************************************
 * A.6.6 Conditional statements
 ********************************************************************/
void conditional_statement() : {} {
	<IF> <LPAREN> cond_predicate() <RPAREN> statement_or_null() [ LOOKAHEAD(1) <ELSE> statement_or_null() ]
	| unique_priority_if_statement()
}

void unique_priority_if_statement() : {} {
	[ unique_priority() ] <IF> <LPAREN> cond_predicate() <RPAREN> statement_or_null()
	( <ELSE> <IF> <LPAREN> cond_predicate() <RPAREN> statement_or_null())*
	[ <ELSE> statement_or_null() ]
}

void unique_priority() : {} {
	<UNIQUE> | <PRIORITY>
}

void cond_predicate() : {} {
	expression_or_cond_pattern() ( "&&&" expression_or_cond_pattern() )*
}

void expression_or_cond_pattern() : {} {
	//expression() | cond_pattern()
	expression() [<MATCHES> pattern()]
}

void cond_pattern() : {} {
	expression() <MATCHES> pattern()
}

/********************************************************************
 * A.6.7 case statements
 ********************************************************************/

void case_statement() : {} {
	/* NOTE: using case_keyword() leaves a hole
	[ unique_priority() ] case_keyword() <LPAREN> expression() <RPAREN> case_item() ( case_item())* <ENDCASE>
	| [ unique_priority() ] case_keyword() <LPAREN> expression() <RPAREN> <MATCHES> case_pattern_item() ( case_pattern_item())* <ENDCASE>
	| [ unique_priority() ] <CASE> <LPAREN> expression() <RPAREN> <INSIDE> case_inside_item() ( case_inside_item())* <ENDCASE>
     */
	[ unique_priority() ] case_keyword() <LPAREN> expression() <RPAREN> 
				(case_item() ( case_item())* 
				| <MATCHES> case_pattern_item() ( case_pattern_item())* 
				| <INSIDE> case_inside_item() ( case_inside_item())* 
				)
				<ENDCASE>
}

void case_keyword() : {} {
	<CASE> | <CASEZ> | <CASEX>
}

void case_item() : {} {
	expression() ( <COMMA> expression())* ":" statement_or_null()
	| <T_DEFAULT> [ ":" ] statement_or_null()
}

void case_pattern_item() : {} {
	pattern() [ "&&&" expression() ] ":" statement_or_null()
	| <T_DEFAULT> [ ":" ] statement_or_null()
}

void case_inside_item() : {} {
	open_range_list() ":" statement_or_null()
	| <T_DEFAULT> [ ":" ] statement_or_null()
}

void randcase_statement() : {} {
	<RANDCASE> randcase_item() ( randcase_item())* <ENDCASE>
}

void randcase_item() : {} {
	expression() ":" statement_or_null()
}

/********************************************************************
 * A.6.7.1 Patterns
 ********************************************************************/ 
void pattern() :{} {
	"." identifier()
	| ".*"
	| constant_expression()
	// CHG: pattern can expand to "", so remove []
	| <TAGGED> identifier() pattern()
	| "�{" pattern() (<COMMA> pattern())* "}"
	| "�{" identifier() ":" pattern() ( <COMMA> identifier() ":" pattern())* "}"
}

void assignment_pattern() : {} {
	"'{" 
		(
			expression() ( <COMMA> expression())* 
			| structure_pattern_key() ":" expression() ( <COMMA> structure_pattern_key() ":" expression())* 
			| array_pattern_key() ":" expression() ( <COMMA> array_pattern_key() ":" expression())* 
			| constant_expression() "{" expression() ( <COMMA> expression() )* "}" 
		)
	"}"
}

	
void structure_pattern_key() : {} {
	identifier() | assignment_pattern_key()
}
	
void array_pattern_key() : {} {
	constant_expression() | assignment_pattern_key()
}
	
void assignment_pattern_key() : {} {
	simple_type() | <T_DEFAULT>
}
	
void assignment_pattern_expression() : {} {
	[ assignment_pattern_expression_type() ] assignment_pattern()
}

void assignment_pattern_expression_type() : {} {
	ps_identifier() | ps_parameter_identifier() | integer_atom_type()
}
	
void constant_assignment_pattern_expression() : {} {
	assignment_pattern_expression()
}

void assignment_pattern_net_lvalue() : {} {
	"'{" net_lvalue() ( <COMMA> net_lvalue())* "}"
}

void assignment_pattern_variable_lvalue() : {} {
	"'{" variable_lvalue() ( <COMMA> variable_lvalue())* "}"
}

/********************************************************************
 * A.6.8 Looping statements  
 ********************************************************************/
void loop_statement() : {} {
	<FOREVER> statement_or_null()
	| <REPEAT> <LPAREN> expression() <RPAREN> statement_or_null()
	| <WHILE> <LPAREN> expression() <RPAREN> statement_or_null()
	| <FOR> <LPAREN> for_initialization() <SEMICOLON> expression() <SEMICOLON> for_step() <RPAREN>
		statement_or_null()
	| <DO> statement_or_null() <WHILE> <LPAREN> expression() <RPAREN> <SEMICOLON>
	| <FOREACH> <LPAREN> identifier() "[" loop_variables() "]" <RPAREN> statement()
}

void for_initialization() : {} {
	list_of_variable_assignments()
	| for_variable_declaration() ( <COMMA> for_variable_declaration())*
}

void for_variable_declaration() : {} {
	data_type() identifier() <EQ_1> expression()
		( LOOKAHEAD(1) <COMMA> identifier() <EQ_1> expression())*
}

void for_step() : {} {
	for_step_assignment() ( <COMMA> for_step_assignment() )*
}

void for_step_assignment() : {} {
	operator_assignment()
	| inc_or_dec_expression()
	| subroutine_call()
}

void loop_variables() : {} {
	"[" identifier() "]" ( <COMMA> "[" identifier() "]")*
}

/********************************************************************
 * A.6.9 Subroutine call statements  
 ********************************************************************/

void subroutine_call_statement() : {} {
	subroutine_call() <SEMICOLON>
	| <VOID> "'" <LPAREN> subroutine_call() <RPAREN> <SEMICOLON>
}

/********************************************************************
 * A.6.10 Assertion statements  
 ********************************************************************/

void procedural_assertion_statement() : {} {
	LOOKAHEAD(2) concurrent_assertion_statement()
	| immediate_assert_statement()
}

void immediate_assert_statement() : {} {
	<ASSERT> <LPAREN> expression() <RPAREN> action_block()
}

/********************************************************************
 * A.6.11 Clocking block  
 ********************************************************************/

void clocking_declaration() : {} {
	[ <T_DEFAULT> ] <CLOCKING> [ identifier() ] clocking_event() <SEMICOLON>
	( clocking_item() )*
	<ENDCLOCKING> [ ":" identifier() ]
}

void clocking_event() : {} {
	"@"	( identifier() | <LPAREN> event_expression() <RPAREN> ) 
}

void clocking_item() : {} {
	<T_DEFAULT> default_skew() <SEMICOLON>
	| clocking_direction() list_of_clocking_decl_assign() <SEMICOLON>
	| ( attribute_instance() )* concurrent_assertion_item_declaration()
}

void default_skew() : {} {
	<INPUT> clocking_skew() [<OUTPUT> clocking_skew()]
	| <OUTPUT> clocking_skew()
}

void clocking_direction() : {} {
	<OUTPUT> [ clocking_skew() ]
	| <INPUT> [ clocking_skew() ] [<OUTPUT> [ clocking_skew() ]]
	| <INOUT>
}

void list_of_clocking_decl_assign() : {} {
	clocking_decl_assign() ( <COMMA> clocking_decl_assign() )*
}

void clocking_decl_assign() : {} {
	identifier() [ <EQ_1> expression() ]
}

void clocking_skew() : {} {
	edge_identifier() [ delay_control() ]
	| delay_control()
}

void clocking_drive() : {} {
	clockvar_expression() <LE> [ cycle_delay() ] expression()
	| cycle_delay() clockvar_expression() <LE> expression()
}

void cycle_delay() : {} {
	"##" 
		(
			integral_number()
			| identifier()
			| <LPAREN> expression() <RPAREN>
		) 
}

void clockvar_expression() : {} {	
	hierarchical_identifier() select()
}

/****************************************************************************
 * A.6.12 Randsequence
 ****************************************************************************/

void randsequence_statement() : {} {
	<RANDSEQUENCE> <LPAREN> [ identifier() ] <RPAREN>
	production() ( production() )*
	<ENDSEQUENCE>
}

void production() : {} {
	[ LOOKAHEAD(1) function_data_type() ] identifier() [ <LPAREN> tf_port_list() <RPAREN> ] ":" rs_rule() ( "|" rs_rule() )* <SEMICOLON>
}

void rs_rule() : {} {
	rs_production_list() [ ":=" weight_specification() [ rs_code_block() ] ]
}

void rs_production_list() : {} {
	rs_prod() ( rs_prod() )*
	| <RAND> <JOIN> [ <LPAREN> expression() <RPAREN> ] production_item() production_item() ( production_item() )*
}

void weight_specification() : {} {
	integral_number()
	| ps_identifier()
	| <LPAREN> expression() <RPAREN>
}

void rs_code_block() : {} {
	"{" ( LOOKAHEAD(1) data_declaration() )* ( statement_or_null() )* "}"
}

void rs_prod() : {} {
	production_item()
	| rs_code_block()
	| rs_if_else()
	| rs_repeat()
	| rs_case()
}

void production_item() : {} {
	identifier() [ <LPAREN> list_of_arguments() <RPAREN> ]
}

void rs_if_else() : {} {
	<IF> <LPAREN> expression() <RPAREN> production_item() [ <ELSE> production_item() ]
}

void rs_repeat() : {} {
	<REPEAT> <LPAREN> expression() <RPAREN> production_item()
}

void rs_case() : {} {
	<CASE> <LPAREN> expression() <RPAREN> rs_case_item() ( rs_case_item() )* <ENDCASE>
}

void rs_case_item() : {} {
	expression() ( <COMMA> expression() )* ":" production_item() <SEMICOLON>
	| <T_DEFAULT> [ ":" ] production_item() <SEMICOLON>
}

/****************************************************************************
 * A.7 Specify section
 ****************************************************************************/

/********************************************************************
 * A.7.1 Specify block declaration
 ********************************************************************/

void specify_block() : {} {
	<SPECIFY> ( specify_item() )* <ENDSPECIFY>
}

void specify_item() : {} {
	specparam_declaration()
	| pulsestyle_declaration()
	| showcancelled_declaration()
	| path_declaration()
	
	// FIXME:
	/*
	| system_timing_check()
	 */
}

void pulsestyle_declaration() : {} {
	<PULSESTYLE_ONEVENT> list_of_path_outputs() <SEMICOLON>
	| <PULSESTYLE_ONDETECT> list_of_path_outputs() <SEMICOLON>
}

void showcancelled_declaration() : {} {
	<SHOWCANCELLED> list_of_path_outputs() <SEMICOLON>
	| <NOSHOWCANCELLED> list_of_path_outputs() <SEMICOLON>
}

/********************************************************************
 * A.7.2 Specify path declarations
 ********************************************************************/

void path_declaration() : {} {
	simple_path_declaration() <SEMICOLON>
	| edge_sensitive_path_declaration() <SEMICOLON>
	| state_dependent_path_declaration() <SEMICOLON>
}

void simple_path_declaration() : {} {
	(parallel_path_description() | full_path_description()) <EQ_1> path_delay_value()
}

void parallel_path_description() : {} {
	<LPAREN> specify_input_terminal_descriptor() [ polarity_operator() ] "=>" specify_output_terminal_descriptor() <RPAREN>
}

void full_path_description() : {} {
	<LPAREN> list_of_path_inputs() [ polarity_operator() ] "*>" list_of_path_outputs() <RPAREN>
}

void list_of_path_inputs() : {} {
	specify_input_terminal_descriptor() ( <COMMA> specify_input_terminal_descriptor() )*
}

void list_of_path_outputs() : {} {
	specify_output_terminal_descriptor() ( <COMMA> specify_output_terminal_descriptor() )*
}

/********************************************************************
 * A.7.3 Specify block terminals
 ********************************************************************/

void specify_input_terminal_descriptor() : {} {
	input_identifier() [ "[" constant_range_expression() "]" ]
}

void specify_output_terminal_descriptor() : {} {
	output_identifier() [ "[" constant_range_expression() "]" ]
}

void input_identifier() : {} {
	identifier() ["." identifier()]
}

void output_identifier() : {} {
	identifier() ["." identifier()]
}

/********************************************************************
 * A.7.4 Specify path delays
 ********************************************************************/

void path_delay_value() :{} {
	list_of_path_delay_expressions()
	// CHG: eliminate, since parens are possible | <LPAREN> list_of_path_delay_expressions() <RPAREN>
}

void list_of_path_delay_expressions() : {} {
	t_path_delay_expression()
	| trise_path_delay_expression() <COMMA> tfall_path_delay_expression()
	| trise_path_delay_expression() <COMMA> tfall_path_delay_expression() <COMMA> tz_path_delay_expression()
	| t01_path_delay_expression() <COMMA> t10_path_delay_expression() <COMMA> t0z_path_delay_expression() <COMMA>
		tz1_path_delay_expression() <COMMA> t1z_path_delay_expression() <COMMA> tz0_path_delay_expression()
	| t01_path_delay_expression() <COMMA> t10_path_delay_expression() <COMMA> t0z_path_delay_expression() <COMMA>
		tz1_path_delay_expression() <COMMA> t1z_path_delay_expression() <COMMA> tz0_path_delay_expression() <COMMA>
		t0x_path_delay_expression() <COMMA> tx1_path_delay_expression() <COMMA> t1x_path_delay_expression() <COMMA>
		tx0_path_delay_expression() <COMMA> txz_path_delay_expression() <COMMA> tzx_path_delay_expression()
}

void t_path_delay_expression() : {} {
	path_delay_expression()
}

void trise_path_delay_expression() : {} {
	path_delay_expression()
}

void tfall_path_delay_expression() : {} {
	path_delay_expression()
}

void tz_path_delay_expression() : {} {
	path_delay_expression()
}

void t01_path_delay_expression() : {} {
	path_delay_expression()
}

void t10_path_delay_expression() : {} {
	path_delay_expression()
}

void t0z_path_delay_expression() : {} {
	path_delay_expression()
}

void tz1_path_delay_expression() : {} {
	path_delay_expression()
}

void t1z_path_delay_expression() : {} {
	path_delay_expression()
}

void tz0_path_delay_expression() : {} {
	path_delay_expression()
}

void t0x_path_delay_expression() : {} {
	path_delay_expression()
}

void tx1_path_delay_expression() : {} {
	path_delay_expression()
}

void t1x_path_delay_expression() : {} {
	path_delay_expression()
}

void tx0_path_delay_expression() : {} {
	path_delay_expression()
}

void txz_path_delay_expression() : {} {
	path_delay_expression()
}

void tzx_path_delay_expression() : {} {
	path_delay_expression()
}

void path_delay_expression() : {} {
	constant_mintypmax_expression()
}

void edge_sensitive_path_declaration() : {} {
	parallel_edge_sensitive_path_description() <EQ_1> path_delay_value()
	| full_edge_sensitive_path_description() <EQ_1> path_delay_value()
}

void parallel_edge_sensitive_path_description() : {} {
	<LPAREN> [ edge_identifier() ] specify_input_terminal_descriptor() "=>"
		<LPAREN> specify_output_terminal_descriptor() [ polarity_operator() ] ":" data_source_expression() <RPAREN> <RPAREN>
}

void full_edge_sensitive_path_description() : {} {
	<LPAREN> [ edge_identifier() ] list_of_path_inputs() "*>"
		<LPAREN> list_of_path_outputs() [ polarity_operator() ] ":" data_source_expression() <RPAREN> <RPAREN>
}

void data_source_expression() : {} {
	expression()
}

void edge_identifier() : {} {
	<POSEDGE> | <NEGEDGE>
}

void state_dependent_path_declaration() : {} {
	<IF> <LPAREN> module_path_expression() <RPAREN>	
		(simple_path_declaration() | edge_sensitive_path_declaration())
		
// edge_sensitive:
// 	parallel_edge_sensitive_path_description() <EQ_1> path_delay_value()
//	| full_edge_sensitive_path_description() <EQ_1> path_delay_value()

// simple_path:
//	parallel_path_description() <EQ_1> path_delay_value()
//	| full_path_description() <EQ_1> path_delay_value()



	| <IFNONE> simple_path_declaration()
}

void polarity_operator() :
{
}
{
	<PLUS> | "-"
}

/*
A.7.5 System timing checks
A.7.5.1 System timing check commands
system_timing_check ::=
$setup_timing_check
| $hold_timing_check
| $setuphold_timing_check
| $recovery_timing_check
| $removal_timing_check
| $recrem_timing_check
| $skew_timing_check
| $timeskew_timing_check
| $fullskew_timing_check
| $period_timing_check
| $width_timing_check
| $nochange_timing_check
$setup_timing_check ::=
$setup ( data_event , reference_event , timing_check_limit [ , [ notifier ] ] ) ;
$hold_timing_check ::=
$hold ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$setuphold_timing_check ::=
$setuphold ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ stamptime_condition ] [ , [ checktime_condition ]
[ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;
$recovery_timing_check ::=
$recovery ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$removal_timing_check ::=
$removal ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$recrem_timing_check ::=
$recrem ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ stamptime_condition ] [ , [ checktime_condition ]
[ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;
$skew_timing_check ::=
$skew ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$timeskew_timing_check ::=
$timeskew ( reference_event , data_event , timing_check_limit
[ , [ notifier ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ;
$fullskew_timing_check ::=
$fullskew ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ;
$period_timing_check ::=
$period ( controlled_reference_event , timing_check_limit [ , [ notifier ] ] ) ;
$width_timing_check ::=
$width ( controlled_reference_event , timing_check_limit , threshold [ , [ notifier ] ] ) ;
$nochange_timing_check ::=
$nochange ( reference_event , data_event , start_edge_offset ,
end_edge_offset [ , [ notifier ] ] ) ;
A.7.5.2 System timing check command arguments
checktime_condition ::= mintypmax_expression
controlled_reference_event ::= controlled_timing_check_event
data_event ::= timing_check_event
delayed_data ::=
terminal_identifier
| terminal_identifier [ constant_mintypmax_expression ]
delayed_reference ::=
terminal_identifier
| terminal_identifier [ constant_mintypmax_expression ]
end_edge_offset ::= mintypmax_expression
event_based_flag ::= constant_expression
notifier ::= variable_identifier
reference_event ::= timing_check_event
remain_active_flag ::= constant_mintypmax_expression
stamptime_condition ::= mintypmax_expression
start_edge_offset ::= mintypmax_expression
threshold ::=constant_expression
timing_check_limit ::= expression
A.7.5.3 System timing check event definitions
timing_check_event ::=
[timing_check_event_control] specify_terminal_descriptor [ &&& timing_check_condition ]
controlled_timing_check_event ::=
timing_check_event_control specify_terminal_descriptor [ &&& timing_check_condition ]
timing_check_event_control ::=
posedge
| negedge
| edge_control_specifier
specify_terminal_descriptor ::=
specify_input_terminal_descriptor
| specify_output_terminal_descriptor
edge_control_specifier ::= edge [ edge_descriptor { , edge_descriptor } ]
edge_descriptor1 ::= 01 | 10 | z_or_x zero_or_one | zero_or_one z_or_x
zero_or_one ::= 0 | 1
z_or_x ::= x | X | z | Z
timing_check_condition ::=
scalar_timing_check_condition
| ( scalar_timing_check_condition )
scalar_timing_check_condition ::=
expression
| ~ expression
| expression == scalar_constant
| expression === scalar_constant
| expression != scalar_constant
| expression !== scalar_constant
scalar_constant ::= 1�b0 | 1�b1 | 1�B0 | 1�B1 | �b0 | �b1 | �B0 | �B1 | 1 | 0
*/

/****************************************************************************
 * A.8 Expressions
 ****************************************************************************/

/********************************************************************
 * A.8.1 Concatenations  
 ********************************************************************/

void concatenation() : {} {
	"{" expression() ( <COMMA> expression() )* "}"
}

void constant_concatenation() : {} {
	"{" constant_expression() ( <COMMA> constant_expression() )* "}"
}

void constant_multiple_concatenation() : {} {
	"{" constant_expression() constant_concatenation() "}"
}

void module_path_concatenation() : {} {
	"{" module_path_expression() ( <COMMA> module_path_expression() )* "}"
}

void module_path_multiple_concatenation() : {} {
	"{" constant_expression() module_path_concatenation() "}"
}

void multiple_concatenation() : {} {
	"{" expression() concatenation() "}"
}

void streaming_concatenation() : {} {
	// CHG: slice_size() can expand to "", so remove []
	"{" stream_operator() slice_size() stream_concatenation() "}"
}

void stream_operator() : {} {
	<RS> | <LS>
}

void slice_size() : {} {
	simple_type() | constant_expression()
}

void stream_concatenation() : {} {
	"{" stream_expression() ( <COMMA> stream_expression() )* "}"
}

void stream_expression() : {} {
	expression() [ <WITH> "[" array_range_expression() "]" ]
}

void array_range_expression() : {} {
	expression() [ (":" | "+:" | "-:") expression() ]
}

void empty_queue() : {} {
	"{" "}"
}

/********************************************************************
 * A.8.2 Subroutine calls  
 ********************************************************************/

void constant_function_call() : {} {
	subroutine_call()
}

void tf_call() : {} {
	ps_or_hierarchical_tf_identifier() (attribute_instance())* [ <LPAREN> list_of_arguments() <RPAREN> ]
}

void system_tf_call() : {} {
	system_tf_identifier() [ <LPAREN> list_of_arguments() <RPAREN> ]
	| system_tf_identifier() <LPAREN> data_type() [ <COMMA> expression() ] <RPAREN>
}

void subroutine_call() : {} {
	tf_call()
	| system_tf_call()
	// method_call():
	//   (method_call_root)
	| (expression_sc() | implicit_class_handle()) "." method_call_body()
		ps_or_hierarchical_tf_identifier() (attribute_instance())* [ <LPAREN> list_of_arguments() <RPAREN> ]
	| randomize_call()
}

void expression_sc() : {} {
//  inc_or_dec_expression():
//	inc_or_dec_operator() (attribute_instance())* variable_lvalue()
//	| variable_lvalue() (attribute_instance())* inc_or_dec_operator()

  (
	// primary_sc()
	(
		primary_literal()
		| [ implicit_class_handle() "." | package_or_class_scope() ] hierarchical_identifier() select()
		| empty_queue()
		| concatenation()
		| multiple_concatenation()
		// FIXME: workaround to eliminate left recursion -- just for now
		// | subroutine_call()
		| <LPAREN> mintypmax_expression() <RPAREN>
		| cast()
		| assignment_pattern_expression()
		| streaming_concatenation()
		| sequence_method_call()
		| <THIS>
		| "$"
		| <NULL>
	)
	| unary_operator() (attribute_instance())* primary()
	| inc_or_dec_expression()
	
	
	| <LPAREN> operator_assignment() <RPAREN>
	| conditional_expression()
	| tagged_union_expression()
  ) 
  [
	<PLUS> (attribute_instance())* expression_sc() |  
	<INSIDE> "{" open_range_list() "}"
  ]
}

void expression_sc_2() : {} {
  (
	binary_operator() (attribute_instance())* expression_sc() |  
	<INSIDE> "{" open_range_list() "}"
  ) expression_sc()
}

void list_of_arguments() : {} {
	// CHG: expression() can expand to "", so remove []
	expression() (<COMMA> expression() )* ( <COMMA> "." identifier() <LPAREN> expression() <RPAREN> )*
	// CHG: expression() can expand to "", so remove []
	| "." identifier() <LPAREN> expression() <RPAREN> ( <COMMA> "." identifier() <LPAREN> expression() <RPAREN>)*
}

void method_call_body() : {} {
	/*
	identifier() (attribute_instance())* [ <LPAREN> list_of_arguments() <RPAREN> ]
	| built_in_method_call()
	 */
	(identifier() | <UNIQUE> | <AND> | <OR> | <XOR>) (attribute_instance())* [ <LPAREN> list_of_arguments() <RPAREN> ]
	| randomize_call()
}

void built_in_method_call() : {} {
	array_manipulation_call()
	| randomize_call()
}

void array_manipulation_call() : {} {
	array_method_name() (attribute_instance())*
	[ <LPAREN> list_of_arguments() <RPAREN> ]
	[ <WITH> <LPAREN> expression() <RPAREN> ]
}

void randomize_call() : {} {
	<RANDOMIZE> (LOOKAHEAD(1) attribute_instance())*
	[ LOOKAHEAD(1) <LPAREN> [ <NULL> | variable_identifier_list() ] <RPAREN> ]
// FIXME:	[ <WITH> constraint_block() ]
}

void array_method_name() : {} {
	identifier() | <UNIQUE> | <AND> | <OR> | <XOR>
}

/********************************************************************
 * A.8.3 Expressions  
 ********************************************************************/
void inc_or_dec_expression() : {} {
	inc_or_dec_operator() (attribute_instance())* variable_lvalue()
	| variable_lvalue() (attribute_instance())* inc_or_dec_operator()
}

void conditional_expression() : {} {
	/* FIXME: introduce parens to eliminate left recursion 
	cond_predicate() <QMARK> (attribute_instance())* expression() ":" expression()
	 */
	<LPAREN> cond_predicate() <RPAREN> <QMARK> (attribute_instance())* expression() ":" expression()
}

void constant_expression() : {} {
	/* CHG: Remove left recursion
	constant_primary()
	| unary_operator() (attribute_instance())* constant_primary()
	| constant_expression() binary_operator() (attribute_instance())* constant_expression()
	| constant_expression() <QMARK> (attribute_instance())* constant_expression() ":" constant_expression()
	 */
	(
		constant_primary()
		| unary_operator() (attribute_instance())* constant_primary()
	) [constant_expression_2()]
}

void constant_expression_2() : {} {
	(
		  binary_operator() (attribute_instance())* constant_expression()
		| <QMARK> (attribute_instance())* constant_expression() ":" constant_expression()
	) constant_expression()
}


void constant_mintypmax_expression() : {} {
	constant_expression() [":" constant_expression() ":" constant_expression()]
}

void constant_param_expression() : {} {
	constant_mintypmax_expression() | data_type() | "$"
}

void param_expression() : {} {
	mintypmax_expression() | data_type()
}

void constant_range_expression() : {} {
	// constant_expression()
	// | constant_part_select_range()
	constant_expression() [ (":" | "+:" | "-:") constant_expression() ]
}

void constant_part_select_range() : {} {
	// constant_range()
	// | constant_indexed_range()
	constant_expression() (":" | "+:" | "-:") constant_expression()
}

void constant_range() : {} {
	constant_expression() ":" constant_expression()
}

void constant_indexed_range() : {} {
	constant_expression() ("+:" | "-:") constant_expression()
}

void expression() : {} {
	/* CHG: eliminate left recursion
	primary()
	| unary_operator() (attribute_instance())* primary()
	| inc_or_dec_expression()
	| <LPAREN> operator_assignment() <RPAREN>
	| expression() binary_operator() (attribute_instance())* expression()
	| conditional_expression()
	| inside_expression()
	| tagged_union_expression()
	 */

//  inc_or_dec_expression():
//	inc_or_dec_operator() (attribute_instance())* variable_lvalue()
//	| variable_lvalue() (attribute_instance())* inc_or_dec_operator()

  (
	primary()
	| unary_operator() (attribute_instance())* primary()
	| inc_or_dec_expression()
	
	
	| <LPAREN> operator_assignment() <RPAREN>
	| conditional_expression()
	// CHG: bring inside_expression() literal up
	// | inside_expression()
	| tagged_union_expression()
  ) 
  [
	<PLUS> (attribute_instance())* expression() |  
	<INSIDE> "{" open_range_list() "}"
  ]
}

void expression_2() : {} {
  (
	binary_operator() (attribute_instance())* expression() |  
	<INSIDE> "{" open_range_list() "}"
  ) expression()
}

void tagged_union_expression() : {} {
	// CHG: expression() can expand to "", so remove []
	<TAGGED> identifier() expression()
}

void inside_expression() : {} {
	expression() <INSIDE> "{" open_range_list() "}"
}

void value_range() : {} {
	expression()
	| "[" expression() ":" expression() "]"
}

void mintypmax_expression() : {} {
	expression() [":" expression() ":" expression()]
}

/* CHG: refactor into module_path_expression() to help
 *      eliminate left recursion
void module_path_conditional_expression() : {} {
	module_path_expression() <QMARK> (attribute_instance())*
	module_path_expression() ":" module_path_expression()
}
 */

void module_path_expression() : {} {
  /* CHG: remove left recursion
	module_path_primary()
	| unary_module_path_operator() (attribute_instance())* module_path_primary()
	| module_path_expression() binary_module_path_operator() (attribute_instance())* module_path_expression()
	| module_path_conditional_expression()
   */

  (
	module_path_primary()
	| unary_module_path_operator() (attribute_instance())* module_path_primary()
  ) [module_path_expression_2()]
}

void module_path_expression_2() : {} {
  (
	<QMARK> (attribute_instance())*
	  module_path_expression() ":" module_path_expression()  
	binary_module_path_operator() (attribute_instance())* module_path_expression()
  ) module_path_expression()
}

void module_path_mintypmax_expression() :
{
}
{
	module_path_expression() [":" module_path_expression() ":" module_path_expression()]
}

void part_select_range() : {} {
	constant_range() | indexed_range()
}

void indexed_range() : {} {
	expression() ("+:" | "-:") constant_expression()
}

void genvar_expression() : {} {
	constant_expression()
}

/********************************************************************
 * A.8.4 Primaries  
 ********************************************************************/
void constant_primary() : {} {
	primary_literal()
	| ps_parameter_identifier() constant_select()
	// CHG: constant_range_expression() can expand to "", so remove []
	| identifier() constant_range_expression()
	| /* genvar_ */ identifier()
	| [ package_scope() | class_scope() ] identifier()
	| constant_concatenation()
	| constant_multiple_concatenation()
	| constant_function_call()
	| <LPAREN> constant_mintypmax_expression() <RPAREN>
	| constant_cast() /* casting_type() "'" <LPAREN> constant_expression() <RPAREN> */
	| constant_assignment_pattern_expression()
	| type_reference()
}

void module_path_primary() : {} {
	/*
	number()
	| identifier()
	| "{" module_path_expression() ( <COMMA> module_path_expression() )* "}"
	| "{" constant_expression() module_path_concatenation() "}"
	| subroutine_call()
	| <LPAREN> module_path_mintypmax_expression() <RPAREN>
	 */
	 
	number()
	| identifier()
	| module_path_concatenation()
	| module_path_multiple_concatenation()
	| subroutine_call()
	| <LPAREN> module_path_mintypmax_expression() <RPAREN>
}

void primary() : {} {
	primary_literal()
	| [ implicit_class_handle() "." | package_or_class_scope() ] hierarchical_identifier() select()
	| empty_queue()
	| concatenation()
	| multiple_concatenation()
	// FIXME: workaround to eliminate left recursion -- just for now
	| subroutine_call()
	| <LPAREN> mintypmax_expression() <RPAREN>
	| cast()
	| assignment_pattern_expression()
	| streaming_concatenation()
	| sequence_method_call()
	| <THIS>
	| "$"
	| <NULL>
}

void time_literal() : {} {
	// CHG: simplify unsigned vs fixed-point
	unsigned_number() [ "." unsigned_number() ] time_unit()
}

void time_unit() :
{
}
{
	<TS_S> | <TS_MS> | <TS_US> | <TS_NS> | <TS_PS> | <TS_FS> | <TS_STEP>
}

void implicit_class_handle() : {} {
	// CHG: eliminate standalone <THIS> . <SUPER> option
	<THIS> ["." <SUPER>] | <SUPER>
}

void bit_select() : {} {
	( "[" expression() "]" )*
}

void select() : {} {
	[ ( "." identifier() bit_select())* "." identifier() ] bit_select() [ "[" part_select_range() "]" ]
}

void constant_bit_select() : {} {
	( "[" constant_expression() "]")*
}

void constant_select() :
{
}
{
	[ ( "." identifier() constant_bit_select())* "." identifier() ] constant_bit_select()
	[ "[" constant_part_select_range() "]" ]
}

void primary_literal() : {} {
	number() | 
	LOOKAHEAD(2) time_literal() | 
	unbased_unsized_literal() | 
	string_literal()
}

void constant_cast() : { } {
	casting_type() "'" <LPAREN> constant_expression() <RPAREN>
}

void cast() : {} {
	casting_type() "'" <LPAREN> expression() <RPAREN>
}

/********************************************************************
 * A.8.5 Expression left-side values  
 ********************************************************************/

void net_lvalue() :
{
}
{
	ps_or_hierarchical_net_identifier() constant_select()
	| "{" net_lvalue() ( <COMMA> net_lvalue() )* "}"
	| [ assignment_pattern_expression_type() ] assignment_pattern_net_lvalue()
}

void variable_lvalue() : {} {
	LOOKAHEAD(2) [ LOOKAHEAD(2) implicit_class_handle() "." | package_scope() ] hierarchical_variable_identifier() select()
	| LOOKAHEAD(2) "{" variable_lvalue() ( <COMMA> variable_lvalue() )* "}"
	| LOOKAHEAD(2) [ assignment_pattern_expression_type() ] assignment_pattern_variable_lvalue()
	| LOOKAHEAD(2) streaming_concatenation()
}

/********************************************************************
 * A.8.6 Operators  
 ********************************************************************/

void unary_operator() :
{
}
{
	<PLUS> | "-" | "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
}

void binary_operator() :
{
}
{
	<PLUS> | "-" | "*" | "/" | "%" | <EQ_2> | <NE_1> | <EQ_3> | <NE_2> | "==?" | "!=?" | "&&" | "||" | "**"
	| <LT> | <LE> | <GT> | <GE> | "&" | "|" | "^" | "^~" | "~^" | <RS> | <LS> | <RLS> | <LLS>
}

void inc_or_dec_operator() :
{
}
{
	"++" | "--"
}

void unary_module_path_operator() :
{
}
{
	"!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
}

void binary_module_path_operator() :
{
}
{
	<EQ_2> | <NE_1> | "&&" | "||" | "&" | "|" | "^" | "^~" | "~^"
}

/********************************************************************
 * A.8.7 Numbers  
 ********************************************************************/
void number() :
{
}
{
	LOOKAHEAD(4) integral_number()
	| LOOKAHEAD(4) real_number()
}

void integral_number() :
{
}
{
	LOOKAHEAD(2) decimal_number()
	| LOOKAHEAD(2) octal_number()
	| LOOKAHEAD(2) binary_number()
	| LOOKAHEAD(2) hex_number()
}

void decimal_number() : {} {
	// CHG: refactor to remove number of alternatives with decimal_base root
	unsigned_number()
	| [ size() ] decimal_base() (
		unsigned_number()
		| x_digit() ( "_" )*
		| z_digit() ( "_" )*
		)
}

void binary_number() :
{
}
{
	[ size() ] binary_base() binary_value()
}

void octal_number() :
{
}
{
	[ size() ] octal_base() octal_value()
}

void hex_number() :
{
}
{
	[ size() ] hex_base() hex_value()
}

void sign() :
{
}
{
	<PLUS> | "-"
}

void size() :
{
}
{
	non_zero_unsigned_number()
}

void non_zero_unsigned_number() : {} {
	//non_zero_decimal_digit() ( "_" | decimal_digit())*
	<NZ_UNSIGNED_VALUE>
}

void real_number() : {} {
	fixed_point_number()
	| LOOKAHEAD(3) unsigned_number() [ "." unsigned_number() ] <EXP> [ sign() ] unsigned_number()
}

void fixed_point_number() : {} {
	unsigned_number() "." unsigned_number()
}

void unsigned_number() : {} {
//	decimal_digit() LOOKAHEAD(1) ( LOOKAHEAD(1) "_" | LOOKAHEAD(1) decimal_digit())*
	<DEC_VALUE>
}

void binary_value() : {} {
	<BINARY_VALUE>
//	binary_digit() ( "_" | binary_digit() )*
}

void octal_value() : {} {
	octal_digit() ( "_" | octal_digit())*
}

void hex_value() : {} {
	<HEX_VALUE>
}

void decimal_base() : {} {
	"'" ["s"|"S"] ("d"|"D")
}

void binary_base() : {} {
	"'" ["s"|"S"]("b"|"B")
}

void octal_base() : {} {
	"'" ["s"|"S"]("o"|"O")
}

void hex_base() : {} {
	"'" ["s"|"S"]("h"|"H")
}

void non_zero_decimal_digit() : {} {
//	1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
	<NZ_DEC_DIGIT>
}

void decimal_digit() : {} {
//	0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
	<DEC_DIGIT>
}

void octal_digit() : {} {
//	x_digit | z_digit | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
	<OCTAL_DIGIT>
}

void z_digit() : {} {
	"z" | "Z" | <QMARK>
}

void x_digit() : {} {
	"x" | "X"
}

void unbased_unsized_literal() : {} {
	"'0" | "'1" | "'" (z_digit() | x_digit())
}

/********************************************************************
 * A.8.8 Strings  
 ********************************************************************/

Token string_literal() :
{
	Token tok = null;
}
{
	(tok = <STRING_LITERAL>) 
	
	{return tok;}
}

/********************************************************************
 *  
 ********************************************************************/

/****************************************************************************
 * A.9 General
 ****************************************************************************/

/****************************************************************************
 * A.9.1 Attributes
 ****************************************************************************/
void attribute_instance() : {}
{
	<ATTR_START> attr_spec() ( <COMMA> attr_spec())*  <ATTR_END>
}

void attr_spec() : {} {
	identifier() [ <EQ_1> constant_expression() ]
}

/****************************************************************************
 * A.9.2 Comments
 ****************************************************************************/


/****************************************************************************
 * A.9.3 Identifiers
 ****************************************************************************/

Token c_identifier() :
{
	Token tok;
}
{
	( tok = <C_IDENT>)
	
	{return tok;}
}

Token escaped_identifier() :
{
	Token tok;
}
{
	(<ESCAPE> {tok = skipToSpace();})
	{return tok;}
}

JAVACODE
Token skipToSpace()
{
    Token current = token;
    Token token ;
    int lastColumn=-1;
    StringBuffer image = new StringBuffer();

    for(;;) 
    { 
    	    token = getToken(1);
            
            if (token.kind == EOF)
                    unexpectedEof(current);
            //if there was a break
            if (token.beginColumn != lastColumn+1 && lastColumn!=-1)
            {
                    break ;
            }
            lastColumn=token.endColumn;

            image.append(token.image);
            getNextToken();
    }
    token.image = image.toString();
    return token ;
}

JAVACODE
void unexpectedEof(Token token)
{
	throw new RuntimeException("unexpected EOF");
	/*
	ParseException ex = new ParseException("unexpected EOF");
	ex.currentToken = token;
	throw ex;
	 */
}


Token hierarchical_dynamic_array_variable_identifier() :
{
	Token tok;
}
{
	(tok  = hierarchical_variable_identifier())
	{return tok;}
}

Token hierarchical_event_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_identifier() :
{
	Token tok = null;
}
{
	// TODO: figure out how to concat these together
	[ <ROOT> "." ] ( identifier() constant_bit_select() "." )* identifier()
	{return tok;}
}

Token hierarchical_net_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_parameter_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_task_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_tf_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_variable_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok; }
}

Token identifier() :
{
	Token tok;
}
{
	(tok = simple_identifier() | tok = escaped_identifier())
	{
		return tok;
	}
}

void package_scope() : { } {
	(identifier() | <UNIT>) "::"
}

void package_or_class_scope() : {} {
/*
	ps_identifier() [ parameter_value_assignment() ]
		( "::" identifier() [ parameter_value_assignment() ])*
 */
	(identifier() | <UNIT>) "::"
}

void ps_identifier() : {} {
	[ LOOKAHEAD(2) package_scope() ] identifier()
}

void ps_or_hierarchical_net_identifier() :
{
}
{
	[ LOOKAHEAD(2) package_scope() ] identifier() | hierarchical_net_identifier()
}

void ps_or_hierarchical_tf_identifier() :
{
}
{
	[ LOOKAHEAD(2) package_scope() ] identifier() | hierarchical_tf_identifier()
}

void ps_parameter_identifier() : {} {
	/*
	[ package_scope() ] parameter_identifier()
	| ( identifier() [ "[" constant_expression() "]" ] "." )* parameter_identifier()
	 */
	([LOOKAHEAD(2) package_scope()]
	 | ( identifier() [ "[" constant_expression() "]" ] "." )*
	) identifier()
}

Token simple_identifier() :
{
	Token tok;
}
{
	(tok = <S_IDENT> | tok = <C_IDENT>)
	{return tok;}
}

Token system_tf_identifier() :
{
	Token tok;
}
{
	(tok = <TF_IDENT>)
	{return tok;}
}


